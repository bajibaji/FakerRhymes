<!DOCTYPE html>
<html lang="zh">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>废壳韵脚生成器 v1.7.1 </title>
	<link rel="preconnect" href="https://unpkg.com" />
	<link href="https://cdn.jsdelivr.net/npm/remixicon@4.1.0/fonts/remixicon.css" rel="stylesheet" />
	<style>
		:root {
			--bg: #1b0d22;
			--panel: #111827;
			--card: #0b1220;
			--text: #e2e8f0;
			--muted: #94a3b8;
			--accent: #7c3aed;
			--accent-2: #22d3ee;
			--border: #1f2937;
			--radius: 16px;
		}

		* {
			box-sizing: border-box;
		}

		body {
			margin: 0;
			min-height: 100vh;
			background: radial-gradient(circle at 20% 20%, rgba(124, 58, 237, 0.2), transparent 35%),
				radial-gradient(circle at 80% 10%, rgba(34, 211, 238, 0.2), transparent 30%),
				radial-gradient(circle at 50% 80%, rgba(56, 189, 248, 0.15), transparent 35%),
				var(--bg);
			color: var(--text);
			font-family: "DM Sans", "Segoe UI", system-ui, -apple-system, sans-serif;
			display: flex;
			align-items: center;
			justify-content: center;
			padding: 40px 16px 64px;
		}

		.shell {
			width: min(1000px, 100%);
			background: linear-gradient(145deg, rgba(255, 255, 255, 0.03), rgba(255, 255, 255, 0));
			border: 1px solid var(--border);
			border-radius: var(--radius);
			box-shadow: 0 30px 80px rgba(0, 0, 0, 0.35);
			overflow: hidden;
		}

		header {
			padding: 28px 32px 12px;
		}

		h1 {
			margin: 0;
			font-size: 28px;
			letter-spacing: 0.4px;
		}

		p.credit {
			margin: 6px 0 0;
			color: var(--muted);
			font-size: 12px;
			text-align: center;
		}

		p.subtitle {
			margin: 8px 0 0;
			color: var(--muted);
			font-size: 14px;
		}

		main {
			display: grid;
			grid-template-columns: 1.1fr 0.9fr;
			gap: 20px;
			padding: 0 32px 28px;
		}

		/* 让下面的 section 也使用相同的宽度对齐 */
		.shell > section {
			margin: 0 32px 20px 32px;
		}

		.shell > .footer {
			margin: 0;
		}

		@media (max-width: 900px) {
			main {
				grid-template-columns: 1fr;
			}
		}

		@media (max-width: 600px) {
			body {
				padding: 20px 12px 40px;
			}
			header {
				padding: 20px 20px 8px;
			}
			h1 {
				font-size: 24px;
			}
			main {
				padding: 0 20px 20px;
			}
			.panel {
				padding: 16px;
			}
			.btn {
				padding: 10px 16px;
				font-size: 14px;
			}
			.btn.small {
				padding: 6px 10px;
				font-size: 12px;
			}
			textarea,
			input[type="text"] {
				padding: 12px;
				font-size: 15px; /* 防止iOS缩放 */
				min-height: 100px;
			}
			.controls {
				gap: 6px;
			}
			table {
				font-size: 12px;
			}
			th, td {
				padding: 6px;
			}
			.footer {
				padding: 8px 20px 16px;
				font-size: 11px;
			}
		}

		.panel {
			background: var(--panel);
			border: 1px solid var(--border);
			border-radius: calc(var(--radius) - 4px);
			padding: 20px;
			position: relative;
			overflow: hidden;
		}

		.panel::before {
			content: "";
			position: absolute;
			inset: 0;
			background: radial-gradient(circle at 30% 30%, rgba(124, 58, 237, 0.08), transparent 40%);
			pointer-events: none;
		}

		label {
			display: flex;
			align-items: center;
			justify-content: space-between;
			gap: 12px;
			font-weight: 600;
			margin-bottom: 10px;
		}

		textarea,
		input[type="text"] {
			width: 100%;
			background: var(--card);
			border: 1px solid var(--border);
			border-radius: 12px;
			padding: 14px;
			color: var(--text);
			font-size: 16px;
			transition: border 0.2s ease, box-shadow 0.2s ease;
			resize: vertical;
			min-height: 120px;
		}

		textarea:focus,
		input[type="text"]:focus {
			border-color: var(--accent);
			outline: none;
			box-shadow: 0 0 0 2px rgba(124, 58, 237, 0.25);
		}

		input[type="range"] {
			-webkit-appearance: none;
			appearance: none;
			width: 100%;
			height: 8px;
			background: rgba(255, 255, 255, 0.3);
			border: 1px solid var(--border);
			border-radius: 4px;
			cursor: pointer;
			outline: none;
		}

		input[type="range"]::-webkit-slider-thumb {
			-webkit-appearance: none;
			appearance: none;
			width: 20px;
			height: 20px;
			border-radius: 50%;
			background: linear-gradient(135deg, var(--accent), var(--accent-2));
			box-shadow: 0 2px 6px rgba(124, 58, 237, 0.3);
			cursor: pointer;
			transition: transform 0.2s ease;
			position: relative;
			z-index: 1;
		}

		input[type="range"]::-webkit-slider-thumb:hover {
			transform: scale(1.1);
		}

		input[type="range"]::-moz-range-thumb {
			width: 20px;
			height: 20px;
			border-radius: 50%;
			background: linear-gradient(135deg, var(--accent), var(--accent-2));
			box-shadow: 0 2px 6px rgba(124, 58, 237, 0.3);
			cursor: pointer;
			border: none;
			transition: transform 0.2s ease;
		}

		input[type="range"]::-moz-range-thumb:hover {
			transform: scale(1.1);
		}

		.controls {
			display: flex;
			flex-wrap: wrap;
			gap: 10px;
			margin-top: 12px;
			align-items: center;
		}

		.btn {
			background: linear-gradient(135deg, var(--accent), var(--accent-2));
			border: none;
			color: white;
			padding: 12px 18px;
			border-radius: 12px;
			font-weight: 700;
			cursor: pointer;
			/* 移除 transform transition，避免与 GSAP 冲突 */
			transition: box-shadow 0.3s ease, background 0.3s ease, border-color 0.3s ease;
			box-shadow: 0 10px 25px rgba(124, 58, 237, 0.25);
			position: relative;
			overflow: hidden;
		}

		/* 移除 CSS hover transform，完全交给 GSAP */
		.btn:hover {
			box-shadow: 0 15px 30px rgba(124, 58, 237, 0.35);
		}

		/* 布局平滑过渡 */
		.shell, main, .panel, textarea, input[type="text"], .footer {
			transition: all 0.6s cubic-bezier(0.16, 1, 0.3, 1);
		}

		.btn.ghost {
			background: transparent;
			color: var(--text);
			border: 1px solid var(--border);
			box-shadow: none;
		text-decoration: none;
		}

		.btn.small {
			padding: 8px 12px;
			font-size: 14px;
			font-weight: 500;
		}

		.hint {
			color: var(--muted);
			font-size: 12px;
			margin-top: 6px;
		}

		.output {
			font-size: 22px;
			line-height: 1.6;
			min-height: 120px;
			word-break: break-all;
			margin-bottom: 10px;
		}

		.badge-row {
			display: flex;
			flex-wrap: wrap;
			gap: 8px;
			margin-top: 10px;
			font-size: 12px;
			color: var(--muted);
		}

		.badge {
			padding: 6px 10px;
			border-radius: 999px;
			background: rgba(124, 58, 237, 0.15);
			border: 1px solid rgba(124, 58, 237, 0.35);
			color: #d8b4fe;
			display: inline-flex;
			align-items: center;
			gap: 6px;
		}

		.fin-input, .tone-select {
			background: transparent;
			border: 1px solid transparent;
			border-radius: 4px;
			padding: 0 2px !important;
			color: var(--text);
			font-size: 13px;
			transition: all 0.2s ease;
			vertical-align: middle;
			height: 22px !important;
			min-height: 0 !important;
			line-height: 22px;
		}

		.fin-input:hover, .tone-select:hover {
			border-color: var(--border);
			background: var(--card);
		}

		.fin-input:focus, .tone-select:focus {
			border-color: var(--accent);
			background: var(--card);
			outline: none;
			box-shadow: 0 0 0 2px rgba(124, 58, 237, 0.2);
		}

		.fin-input {
			width: 32px !important;
			text-align: center;
		}

		.tone-select {
			cursor: pointer;
			width: auto;
		}

		table {
			width: 100%;
			border-collapse: collapse;
			font-size: 13px;
		}

		th,
		td {
			border-bottom: 1px solid var(--border);
			padding: 8px;
			text-align: left;
			color: var(--muted);
		}

		th {
			color: var(--text);
			font-weight: 700;
		}

		.pill {
			display: inline-flex;
			align-items: center;
			gap: 4px;
			padding: 4px 10px;
			border-radius: 10px;
			background: rgba(34, 211, 238, 0.12);
			color: #a5f3fc;
			border: 1px solid rgba(34, 211, 238, 0.35);
			font-weight: 600;
			cursor: pointer;
			user-select: none;
			transition: all 0.2s ease;
		}

		.lock-btn {
			background: transparent;
			border: none;
			color: var(--text);
			padding: 0;
			border-radius: 0;
			cursor: pointer;
			font-size: 12px;
			line-height: 1;
		}

		.lock-btn.locked {
			background: transparent;
			border-color: transparent;
		}

		.pill:hover {
			background: rgba(34, 211, 238, 0.2);
			box-shadow: 0 0 10px rgba(34, 211, 238, 0.15);
		}

		.pill:active {
			transform: scale(0.95);
		}

		.small {
			font-size: 12px;
			color: var(--muted);
		}

		.footer {
			padding: 12px 32px 22px;
			color: var(--muted);
			font-size: 12px;
		}

		/* GSAP Background Blobs */
		.bg-blob {
			position: fixed;
			border-radius: 50%;
			filter: blur(80px);
			z-index: -1;
			opacity: 0.6;
			pointer-events: none;
		}
		.blob-1 { top: -10%; left: -10%; width: 50vw; height: 50vw; background: var(--accent); opacity: 0.15; }
		.blob-2 { bottom: -10%; right: -10%; width: 40vw; height: 40vw; background: var(--accent-2); opacity: 0.15; }
		.blob-3 { top: 40%; left: 40%; width: 30vw; height: 30vw; background: #3b82f6; opacity: 0.1; }

		/* Loading Spinner */
		.btn.loading {
			pointer-events: none;
			position: relative;
		}
		
		.btn.loading .btn-text {
			opacity: 0.5;
		}
		
		.btn.loading::after {
			content: '';
			position: absolute;
			top: 50%;
			left: 50%;
			width: 16px;
			height: 16px;
			margin: -8px 0 0 -8px;
			border: 2px solid rgba(255, 255, 255, 0.3);
			border-top-color: white;
			border-radius: 50%;
			animation: spin 0.6s linear infinite;
		}
		
		@keyframes spin {
			0% { transform: rotate(0deg); }
			100% { transform: rotate(360deg); }
		}

		/* Modal Styles */
		.modal-overlay {
			position: fixed;
			inset: 0;
			background: rgba(0, 0, 0, 0.7);
			backdrop-filter: blur(4px);
			display: none;
			align-items: center;
			justify-content: center;
			z-index: 1000;
			opacity: 0;
			transition: opacity 0.3s ease;
		}

		.modal-overlay.active {
			display: flex;
			opacity: 1;
		}

		.modal-content {
			line-height: 1.6;
			color: var(--text);
		}
		
		.modal-header {
			display: flex;
			align-items: center;
			justify-content: space-between;
			margin-bottom: 20px;
		}

		.modal-header h2 {
			margin: 0;
			font-size: 20px;
			color: var(--accent-2);
		}

		.close-modal {
			background: transparent;
			border: none;
			color: var(--muted);
			font-size: 24px;
			cursor: pointer;
			padding: 0;
			line-height: 1;
		}

		.close-modal:hover {
			color: var(--text);
		}

		.settings-group {
			display: flex;
			flex-direction: column;
			gap: 16px;
		}

		.settings-item {
			display: flex;
			flex-direction: column;
			gap: 8px;
		}

		.settings-item label {
			font-size: 14px;
			margin-bottom: 0;
		}

		/* Segmented Control Styles */
		.segmented-control {
			display: flex;
			background: var(--card);
			border: 1px solid var(--border);
			border-radius: 12px;
			padding: 4px;
			gap: 4px;
			margin-top: 1px;
			width: 100%;
		}

		/* Virtual List Styles removed as per user feedback */
		#matchedResultsList {
			display: flex !important;
			flex-wrap: wrap;
			gap: 8px;
		}

		.virtual-item {
			padding: 6px 12px;
			background: var(--card);
			border: 1px solid var(--border);
			border-radius: 6px;
			color: var(--text);
			font-size: 14px;
		}

		.segment-btn {
			flex: 1;
			background: transparent;
			border: none;
			color: var(--muted);
			padding: 6px 4px;
			font-size: 13px;
			font-weight: 600;
			cursor: pointer;
			border-radius: 8px;
			transition: all 0.4s ease;
			text-align: center;
		}

		.segment-btn:hover {
			color: var(--text);
			background: rgba(255, 255, 255, 0.05);
		}

		.segment-btn.active {
			background: var(--accent);
			color: white;
			box-shadow: 0 2px 8px rgba(124, 58, 237, 0.3);
		}

		/* 最松按钮特殊样式 - 紫红渐变 */
		.segment-btn[data-value="1"].active {
			background: linear-gradient(135deg, #a855f7, #ec4899);
			box-shadow: 0 2px 8px rgba(236, 72, 153, 0.4);
		}

		@media (max-width: 600px) {
			.segment-btn {
				padding: 8px 2px;
				font-size: 12px;
			}
		}

		/* Help Button & Modal */
		.help-btn {
			position: fixed;
			top: 20px;
			right: 20px;
			width: 30px;
			height: 30px;
			background: var(--panel);
			border: 1px solid var(--border);
			border-radius: 50%;
			color: var(--text);
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 18px;
			cursor: pointer;
			z-index: 1000;
			transition: all 0.2s ease;
			box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
		}

		.help-btn:hover {
			background: var(--accent);
			border-color: var(--accent);
			transform: scale(1.1);
		}

		.modal-overlay {
			position: fixed;
			inset: 0;
			background: rgba(0, 0, 0, 0.6);
			backdrop-filter: blur(4px);
			z-index: 2000;
			display: flex;
			align-items: center;
			justify-content: center;
			opacity: 0;
			pointer-events: none;
			transition: opacity 0.3s ease;
		}

		.modal-overlay.active {
			opacity: 1;
			pointer-events: auto;
		}

		.modal {
			background: var(--panel);
			border: none;
			border-radius: var(--radius);
			width: min(700px, 92vw);
			max-height: 85vh;
			overflow-y: auto;
			padding: 32px;
			box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
			transform: translateY(20px);
			transition: transform 0.3s ease;
		}

		.modal::-webkit-scrollbar {
			display: none;
		}

		.modal {
			-ms-overflow-style: none;
			scrollbar-width: none;
		}

		.modal-overlay.active .modal {
			transform: translateY(0);
		}

		.modal-header {
			display: flex;
			align-items: center;
			justify-content: space-between;
			margin-bottom: 20px;
			padding-bottom: 16px;
			border-bottom: 1px solid var(--border);
		}

		.modal-header h2 {
			margin: 0;
			font-size: 20px;
		}

		.modal-close {
			background: transparent;
			border: none;
			color: var(--muted);
			font-size: 24px;
			cursor: pointer;
			padding: 4px;
			line-height: 1;
			border-radius: 4px;
		}

		.modal-close:hover {
			color: var(--text);
			background: rgba(255, 255, 255, 0.1);
		}

		.modal-content {
			line-height: 1.8;
			color: var(--text);
			word-break: break-word;
			overflow-wrap: break-word;
		}
		
		.modal-content h3 {
			margin: 28px 0 14px;
			font-size: 16px;
			color: var(--accent-2);
			border-left: 3px solid var(--accent-2);
			padding-left: 10px;
			font-weight: 600;
		}

		.modal-content h3:first-child {
			margin-top: 0;
		}

		.modal-content ul {
			padding-left: 20px;
			margin: 10px 0 20px 0;
			list-style-type: disc;
		}
		
		.modal-content li {
			margin-bottom: 10px;
			color: var(--muted);
			line-height: 1.7;
			word-break: break-word;
			overflow-wrap: break-word;
		}

		.modal-content p {
			margin-bottom: 14px;
			color: var(--muted);
			line-height: 1.7;
			word-break: break-word;
			overflow-wrap: break-word;
		}

		.modal-content strong {
			color: var(--text);
		}

		/* Loading Splash Screen */
		#loadingSplash {
			position: fixed;
			inset: 0;
			background: var(--bg);
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			z-index: 9999;
			transition: opacity 0.1s ease, visibility 0.1s ease;
		}

		.splash-logo {
			font-size: 48px;
			margin-bottom: 24px;
			background: linear-gradient(135deg, var(--accent), var(--accent-2));
			-webkit-background-clip: text;
			-webkit-text-fill-color: transparent;
			font-weight: 800;
			letter-spacing: -1px;
		}

		.splash-loader {
			width: 40px;
			height: 40px;
			border: 3px solid rgba(255, 255, 255, 0.1);
			border-top-color: var(--accent-2);
			border-radius: 50%;
			animation: spin 1s linear infinite;
		}

		.splash-text {
			margin-top: 20px;
			font-size: 14px;
			color: var(--muted);
			letter-spacing: 2px;
			text-transform: uppercase;
		}

		@media (max-width: 600px) {
			.modal-content h3 {
				font-size: 15px;
				margin: 22px 0 12px;
			}
			
			.modal-content li,
			.modal-content p {
				font-size: 14px;
				line-height: 1.75;
			}
		}
	</style>
</head>
<body>
	<div class="bg-blob blob-1"></div>
	<div class="bg-blob blob-2"></div>
	<div class="bg-blob blob-3"></div>

	<div class="shell">
		<header>
			<h1>废壳韵脚生成器 v1.7.1<span style="font-size: 0.5em;">[网页版]</span></h1>
			<p class="credit">©TRUEPEAK 2026 - DEVELOPED BY DANJUAN </p>
			<p class="subtitle">输入词语，自动提取拼音、声调与韵母，生成每个字同声调同韵母的押韵字串。</p>
		</header>

		<main>
			<section class="panel">
				<div style="display: flex; align-items: center; justify-content: space-between; gap: 12px; font-weight: 600; margin-bottom: 10px;">
					<label for="source">请输入要押韵的词语：</label>
					<a class="btn ghost small" href="custom.html"><i class="ri-file-list-3-line"></i>自定义词库</a>
				</div>
				<textarea id="source" placeholder="示例：废壳"></textarea>

				<div class="controls" style="display: flex; flex-direction: column; gap: 1px; margin-top: 12px;">
					<div style="display: flex; gap: 10px; flex-wrap: wrap;">
						<button class="btn" id="go">生成押韵</button>
						<button class="btn ghost small" id="loadDictBtn" title="从在线词库加载更多汉字">📚 加载词库</button>
						<button class="btn ghost small" id="clearDictBtn" title="清理本地缓存的词库数据" style="color: #ef4444; border-color: rgba(239, 68, 68, 0.2);"><i class="ri-delete-bin-line"></i> 清理缓存</button>
					</div>
					<label class="small" style="margin-top: 10px;">韵脚宽松度</label>
					<div class="segmented-control" id="loosenessSelector">
						<button type="button" class="segment-btn active" data-value="0">严格</button>
						<button type="button" class="segment-btn" data-value="0.5">中等</button>
						<button type="button" class="segment-btn" data-value="1">最松</button>
					</div>
					<input type="hidden" id="looseness" value="0.0" />
					
					<!-- 平仄过滤选择器（仅在最松时显示） -->
					<div id="pingzeFilterContainer" style="display: none; margin-top: 10px; padding: 10px; background: rgba(124, 58, 237, 0.08); border-radius: 8px; border: 1px solid var(--border);">
						<label class="small" style="margin-bottom: 8px; display: block;">平仄过滤（尾字声调）</label>
						<div style="display: flex; gap: 8px; flex-wrap: wrap;">
							<label style="display: flex; align-items: center; gap: 4px; cursor: pointer; font-size: 13px; margin: 0;">
								<input type="radio" name="pingze" value="all" checked style="cursor: pointer;" />
								<span>全部</span>
							</label>
							<label style="display: flex; align-items: center; gap: 4px; cursor: pointer; font-size: 13px; margin: 0;">
								<input type="radio" name="pingze" value="ping" style="cursor: pointer;" />
								<span>平</span>
							</label>
							<label style="display: flex; align-items: center; gap: 4px; cursor: pointer; font-size: 13px; margin: 0;">
								<input type="radio" name="pingze" value="ze" style="cursor: pointer;" />
								<span>仄</span>
							</label>
						</div>
					</div>
				</div>

				<div class="controls" style="display: flex; flex-direction: column; gap: 10px; margin-top: 16px; border-top: 1px solid var(--border); padding-top: 16px;">
					<div style="display: flex; align-items: center; justify-content: space-between; width: 100%;">
						<div style="display: flex; align-items: center; gap: 8px;">
							<input type="checkbox" id="aiMode" style="width: 18px; height: 18px; cursor: pointer;" />
							<label class="small" style="margin-bottom: 0; cursor: pointer;" for="aiMode"><i class="ri-robot-2-line"></i> AI 押韵模式 </label>
						</div>
						<button class="btn ghost small" id="openAiSettings" title="AI 设置"><i class="ri-settings-3-line"></i></button>
					</div>
				</div>

				<div style="color:brown; font-size: small; font-weight: bold; text-align: center; margin-top: 12px;" id="dictWarning">*使用前请先加载词库*</div>
				<div class="hint">严格：同韵同调  | 中等：韵母放宽（鼻音、翘舌） | 最松：韵母进一步放宽，忽略声调。</div>
				<div class="hint">- 生成结果的词是乱码的话，说明没有结果，放宽韵脚宽松度即可</div>
				<div class="hint">- 越宽松需要查询的时间越长，请耐心等待</div>
				
				
			</section>

			<section class="panel">
				<div style="font-weight: 600; margin-bottom: 14px;">生成结果</div>
				<div class="output" id="output"></div>
				<div class="badge-row" id="badges"></div>
			</section>

		</main>

		<section class="panel" style="margin: 0 32px 20px;">
			<label style="margin-bottom: 14px;">音调选择</label>
			<table>
				<thead>
					<tr>
						<th>原字</th>
						<th>拼音</th>
						<th>声调</th>
						<th>韵母</th>
					</tr>
				</thead>
				<tbody id="detailBody"></tbody>
			</table>
		</section>

		<section class="panel" style="margin: 0 32px 20px;">
			<div id="matchedResults" style="padding: 12px; background: rgba(34, 211, 238, 0.05); border: 1px solid var(--border); border-radius: 8px; display: none;">
				<div style="font-weight: 600; margin-bottom: 8px; color: var(--accent-2);">更多匹配结果：</div>
				<div id="matchedResultsList" style="display: flex; flex-wrap: wrap; gap: 8px;"></div>
			</div>
			<div id="dictStatus" style="margin-top: 12px; padding: 8px 12px; background: rgba(124, 58, 237, 0.08); border-radius: 8px; font-size: 12px; color: var(--muted); display: none;">
				<span id="dictStatusText"></span>
			</div>
		</section>

		<div class="footer">词库基于雾凇拼音词库以及中华新华字典数据库以及清华大学开放中文词库，查询算法基于 pinyin-pro 解析。点击"📚 加载词库"可从在线词典获取7000+汉字，数据缓存在本地，可离线使用。</div>
	</div>

	<!-- AI Settings Modal -->
	<div class="modal-overlay" id="aiSettingsModal">
		<div class="modal-content">
			<div class="modal-header">
				<h2><i class="ri-robot-2-line"></i> AI 押韵设置</h2>
				<button class="close-modal" id="closeAiSettings">&times;</button>
			</div>
			<div class="settings-group">
				<div class="settings-item">
					<label for="geminiApiKey">Gemini API Key</label>
					<input type="text" id="geminiApiKey" placeholder="输入 Gemini API Key" style="min-height: 40px; padding: 8px 12px; font-size: 14px;" />
					<div class="hint">没有 Key？<a href="https://aistudio.google.com/app/apikey" target="_blank" style="color: var(--accent-2);">点击获取</a></div>
				</div>
				<div class="settings-item">
					<label for="geminiProxy">API 代理地址 (可选)</label>
					<input type="text" id="geminiProxy" placeholder="例如: https://proxy.com" style="min-height: 40px; padding: 8px 12px; font-size: 14px;" />
					<div class="hint">解决 Failed to fetch 错误。</div>
				</div>
				<div style="margin-top: 10px;">
					<button class="btn" style="width: 100%;" id="saveAiSettings">保存设置</button>
				</div>
			</div>
		</div>
	</div>

	<script src="./data.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js" onerror="console.warn('GSAP CDN加载失败')"></script>
	<script>
		// 开发模式开关（生产环境设为false以禁用console.log）
		const DEV_MODE = false;
		const devLog = (...args) => { if (DEV_MODE) console.log(...args); };
		
		// GSAP Animations
		document.addEventListener("DOMContentLoaded", () => {
			// 检查GSAP是否加载成功
			if (typeof gsap === 'undefined') {
				console.warn('GSAP未加载，跳过动画');
				return;
			}
			gsap.config({ nullTargetWarn: false });

			// 将动画逻辑包装在一个函数中，供加载完成后调用
			window.startMainAnimations = () => {
				// 如果已经在运行了，直接返回
				if (window.isAnimationsStarted) return;
				window.isAnimationsStarted = true;

				// 1. Background Blobs Floating
				gsap.to(".blob-1", {
					x: "20%", y: "20%", duration: 8, repeat: -1, yoyo: true, ease: "sine.inOut"
				});
				gsap.to(".blob-2", {
					x: "-20%", y: "-20%", duration: 10, repeat: -1, yoyo: true, ease: "sine.inOut", delay: 1
				});
				gsap.to(".blob-3", {
					x: "15%", y: "-15%", scale: 1.2, duration: 12, repeat: -1, yoyo: true, ease: "sine.inOut", delay: 2
				});

				// 2. Entry Animations
				const tl = gsap.timeline({ defaults: { ease: "power3.out" } });

				tl.to(".shell", {
					y: 0,
					opacity: 1,
					duration: 1,
					startAt: { y: 30, opacity: 0 },
					clearProps: "all"
				})
				tl.to("header h1", {
					y: 0,
					opacity: 1,
					duration: 0.4,
					startAt: { y: 20, opacity: 0 }
				}, "-=0.8")
				.to("header .subtitle", {
					y: 0,
					opacity: 1,
					duration: 0.2,
					startAt: { y: 10, opacity: 0 }
				}, "-=0.6")
				.to(".panel", {
					y: 0,
					opacity: 1,
					duration: 0.1,
					stagger: 0.15,
					startAt: { y: 30, opacity: 0 },
					clearProps: "all"
				}, "-=0.6")
				.to(".footer", {
					opacity: 1,
					duration: 1,
					startAt: { opacity: 0 },
					clearProps: "all"
				}, "-=0.4");
			};

		// 3. Interactive Elements
		const buttons = document.querySelectorAll(".btn");
		buttons.forEach(btn => {
			btn.addEventListener("mouseenter", () => {
				gsap.to(btn, { scale: 1.05, duration: 0.3, ease: "back.out(1.7)" });
			});
			btn.addEventListener("mouseleave", () => {
				gsap.to(btn, { scale: 0.92, duration: 0.1, ease: "power1.out" });
			});
			btn.addEventListener("mouseup", () => {
				gsap.to(btn, { scale: 1.05, duration: 0.4, ease: "elastic.out(1, 0.3)" });
			});
		});
		
		// Animate output when generated
		window.triggerResultAnimation = () => {
			if (typeof gsap === 'undefined') return;
			gsap.fromTo("#output", { opacity: 0.5, y: 5 }, { opacity: 1, y: 0, duration: 0.4, ease: "power2.out" });
			gsap.fromTo("#badges", { opacity: 0, x: -10 }, { opacity: 1, x: 0, duration: 0.4, delay: 0.1, ease: "power2.out" });
			// Table rows animation
			setTimeout(() => {
				gsap.from("#detailBody tr", {
					opacity: 0,
					x: -10,
					stagger: 0.05,
					duration: 0.4,
					ease: "power2.out",
					clearProps: "all"
				});
			}, 50);
		};

		const goBtn = document.getElementById('go');
		goBtn.addEventListener('click', () => {
			window.triggerResultAnimation();
		});
	});
</script>

<script>
		const cdnList = [
			'https://unpkg.com/pinyin-pro@3.27.0/dist/index.js',
			'https://cdn.jsdelivr.net/npm/pinyin-pro@3.27.0/dist/index.js',
			// 如果需要本地备用，将 pinyin-pro.umd.js 放在同目录并取消下一行注释
			// './pinyin-pro.umd.js'
		];

		const loadScriptSeq = (list, cb) => {
			if (!list.length) return cb(new Error('全部 CDN 加载失败'));
			const [url, ...rest] = list;
			const s = document.createElement('script');
			s.src = url;
			s.onload = () => cb(null, url);
			s.onerror = () => {
				s.remove();
				loadScriptSeq(rest, cb);
			};
			document.head.appendChild(s);
		};

		const setOutputStatus = (msg) => {
			// Output element removed
		};
		const finals = [
			'iong', 'uang', 'iang', 'ueng', 'uan', 'ian', 'uen', 'iao', 'uai', 'ang', 'eng', 'ing', 'ong', 'ai', 'ei', 'ao', 'ou', 'an', 'en', 'in', 'un', 'vn', 'ia', 'ua', 'uo', 'ie', 'ue', 'ui', 'er', 'a', 'o', 'e', 'i', 'u', 'v'
		];

		let bankMap = new Map();
		let pinyinReady = false;
		let currentInfos = [];
		let currentDictResult = null; // 存储字典查询结果
		let dict = null; // 优化字典
		let suffixIndex = new Map(); // 新增：后缀索引，用于支持更长词匹配
		let locks = [];

		// IndexedDB helpers
		const DB_NAME = 'FakerRhymesDB';
		const DB_VERSION = 1;
		const STORE_NAME = 'dictionary';

		function openDB() {
			return new Promise((resolve, reject) => {
				const request = indexedDB.open(DB_NAME, DB_VERSION);
				request.onupgradeneeded = (e) => {
					const db = e.target.result;
					if (!db.objectStoreNames.contains(STORE_NAME)) {
						db.createObjectStore(STORE_NAME);
					}
				};
				request.onsuccess = (e) => resolve(e.target.result);
				request.onerror = (e) => reject(e.target.error);
			});
		}

		async function getFromDB(key) {
			const db = await openDB();
			return new Promise((resolve, reject) => {
				const transaction = db.transaction([STORE_NAME], 'readonly');
				const store = transaction.objectStore(STORE_NAME);
				const request = store.get(key);
				request.onsuccess = (e) => resolve(e.target.result);
				request.onerror = (e) => reject(e.target.error);
			});
		}

		async function getAllKeysFromDB() {
			const db = await openDB();
			return new Promise((resolve, reject) => {
				const transaction = db.transaction([STORE_NAME], 'readonly');
				const store = transaction.objectStore(STORE_NAME);
				const request = store.getAllKeys();
				request.onsuccess = (e) => resolve(e.target.result);
				request.onerror = (e) => reject(e.target.error);
			});
		}

		// 平仄过滤函数：根据尾字声调过滤词语列表
		// pingze: 'all' | 'ping' | 'ze'
		// 平声 = 1, 2声调；仄声 = 3, 4声调
		const filterByPingZe = (phrases, pingze) => {
			if (!pingze || pingze === 'all' || !Array.isArray(phrases)) {
				return phrases;
			}
			
			return phrases.filter(phrase => {
				if (!phrase || phrase.length === 0) return false;
				
				// 获取尾字
				const chars = Array.from(phrase);
				const lastChar = chars[chars.length - 1];
				const lastInfo = toInfo(lastChar);
				
				if (!lastInfo || !lastInfo.tone || lastInfo.tone === '-') {
					return false; // 无法确定声调的词语排除
				}
				
				const tone = Number(lastInfo.tone);
				
				if (pingze === 'ping') {
					// 平声：1、2声
					return tone === 1 || tone === 2;
				} else if (pingze === 'ze') {
					// 仄声：3、4声
					return tone === 3 || tone === 4;
				}
				
				return true;
			});
		};

		// Final to short code mapping
		const finalToCode = {
			'iong': '0', 'uang': '1', 'iang': '2', 'ueng': '3', 'uan': '4', 'ian': '5', 'uen': '6', 'iao': '7', 'uai': '8',
			'ang': '9', 'eng': 'a', 'ing': 'b', 'ong': 'c', 'ai': 'd', 'ei': 'e', 'ao': 'f', 'ou': 'g', 'an': 'h', 'en': 'i',
			'in': 'j', 'un': 'k', 'vn': 'l', 'ia': 'm', 'ua': 'n', 'uo': 'o', 'ie': 'p', 'ue': 'q', 'ui': 'r', 'er': 's',
			'a': 't', 'o': 'u', 'e': 'v', 'i': 'w', 'u': 'x', 'v': 'y', 'i-flat': 'z', 'i-retro': 'A', 'ü': 'B', 'üan': 'C', 'ün': 'D'
		};

		function encodeKey(key) {
			if (!key) return key;
			return key.split('_').map(part => {
				const match = part.match(/^(.+)([0-4])$/);
				if (match) {
					const [_, final, tone] = match;
					return (finalToCode[final] || final) + tone;
				}
				return part;
			}).join('');
		}

		// Bloom Filter implementation
		class BloomFilter {
			constructor(size = 10000, hashCount = 3) {
				this.size = size;
				this.hashCount = hashCount;
				this.bitArray = new Uint8Array(Math.ceil(size / 8));
			}

			_hash(string, seed) {
				let hash = 0;
				for (let i = 0; i < string.length; i++) {
					hash = (hash * 31 + string.charCodeAt(i) + seed) % this.size;
				}
				return hash;
			}

			add(string) {
				for (let i = 0; i < this.hashCount; i++) {
					const index = this._hash(string, i);
					this.bitArray[index >> 3] |= (1 << (index & 7));
				}
			}

			mightContain(string) {
				for (let i = 0; i < this.hashCount; i++) {
					const index = this._hash(string, i);
					if (!(this.bitArray[index >> 3] & (1 << (index & 7)))) {
						return false;
					}
				}
				return true;
			}
		}

		let bloomFilter = new BloomFilter();

		// 加载优化字典
		const loadDict = async () => {
			// 如果已经在加载了，直接返回
			if (window.isDictLoading) return;
			window.isDictLoading = true;

			try {
				// 1. 极速初始化：优先检查本地缓存
				const allKeys = await getAllKeysFromDB();
				if (allKeys && allKeys.length > 0) {
					devLog('从 IndexedDB 发现缓存词库，开始极速索引重建');
					bloomFilter = new BloomFilter(allKeys.length * 10, 3);
					
					// 极致优化：主线程重建索引使用更大的批次和 requestIdleCallback
					const buildBatch = (startIndex) => {
						const batchSize = 15000; // 进一步增加批次
						const endIndex = Math.min(startIndex + batchSize, allKeys.length);
						for (let i = startIndex; i < endIndex; i++) {
							bloomFilter.add(allKeys[i]);
						}
						if (endIndex < allKeys.length) {
							if (window.requestIdleCallback) {
								requestIdleCallback(() => buildBatch(endIndex));
							} else {
								setTimeout(() => buildBatch(endIndex), 0);
							}
						} else {
							window.dictLoaded = true;
							devLog('Bloom Filter 索引重建耗时:', (performance.now() - startTime).toFixed(2), 'ms');
						}
					};
					const startTime = performance.now();
					buildBatch(0);
					window.isDictLoading = false;
					return;
				}

				// 2. 首次启动：使用原生流式解析
				if (typeof Worker !== 'undefined') {
					const worker = new Worker('./dict-worker.js');
					worker.onmessage = (event) => {
						const { type, message, data, progress } = event.data;
						if (type === 'progress') {
							// updateSplash(message, percent ? Math.round(percent * 0.8) : undefined);
						} else if (type === 'parsing') {
							// updateSplash('正在解析数据...', 80 + Math.round(event.data.progress * 0.1));
						} else if (type === 'success') {
							// updateSplash('词库加载成功', 100);
							const startTime = performance.now();
							getAllKeysFromDB().then(keys => {
								bloomFilter = new BloomFilter(keys.length * 10, 3);
								keys.forEach(k => bloomFilter.add(k));
								window.dictLoaded = true;
								devLog('Worker 成功后 Bloom Filter 重建耗时:', (performance.now() - startTime).toFixed(2), 'ms');
								worker.terminate();
							});
						} else if (type === 'error') {
							console.error('后台加载失败:', message);
							worker.terminate();
						}
					};
					worker.postMessage({
						action: 'loadAndProcess',
						payload: { dictSources: [{ name: '核心词库', url: './dict_optimized.json' }] }
					});
				}
			} catch(e) {
				console.error('加载流程异常:', e);
			} finally {
				window.isDictLoading = false;
			}
		};

	const normalize = (p) => p.replace(/\d/g, '').replace(/ü/g, 'v').replace(/u:/g, 'v');

	// 将键统一转成 v 形式，并生成 v/u 双版本，兼容词典中可能用 u 表示 ü 的情况
	const buildKeyVariants = (key) => {
		const base = String(key).replace(/ü/g, 'v').replace(/u:/g, 'v');
			const variants = new Set([base, base.replace(/v/g, 'u')]);
			return Array.from(variants);
		};

		const extractTone = (p) => {
			const m = p.match(/(\d)/);
			return m ? Number(m[1]) : 0;
		};

		const detectFinal = (p) => {
			// 标准化：ü -> v
			let normalizedP = p.replace(/ü/g, 'v').replace(/u:/g, 'v');
			
			// 提取声母（按长度排序，确保 zh 优先于 z）
			const initials = ['zh', 'ch', 'sh', 'z', 'c', 's', 'b', 'p', 'm', 'f', 'd', 't', 'n', 'l', 'g', 'k', 'h', 'j', 'q', 'x', 'r', 'w', 'y'];
			let initial = '';
			for (const init of initials) {
				if (normalizedP.startsWith(init)) {
					initial = init;
					break;
				}
			}
			
			let rest = normalizedP.slice(initial.length);
			
			// 特殊处理：j/q/x/y 后的 u 实际是 ü (v)
			if (['j', 'q', 'x', 'y'].includes(initial) && rest.startsWith('u')) {
				rest = 'v' + rest.slice(1);
			}
			
			// 特殊处理：j/q/x/y 后的 e 实际是 ie（比如 ye -> ie, jie -> ie）
			if (['j', 'q', 'x', 'y'].includes(initial) && rest === 'e') {
				rest = 'ie';
			}

			// --- 新增：i韵隔离协议 (Triple-I Isolation) ---
			if (rest === 'i') {
				if (['z', 'c', 's'].includes(initial)) {
					return { initial, final: 'i-flat' }; // 平舌音
				} else if (['zh', 'ch', 'sh', 'r'].includes(initial)) {
					return { initial, final: 'i-retro' }; // 翘舌音
				}
				// 其他声母（b, p, m, d, t, n, l, j, q, x, y）保持为 'i'
			}
			// -------------------------------------------
			
			// 如果没有韵母（比如 m, n, ng 自成音节），返回原拼音作为韵母
			if (!rest) return { initial, final: normalizedP };
			
			return { initial, final: rest };
		};

		const toInfo = (char) => {
			const raw = window.pinyinPro.pinyin(char, {
				type: 'array',
				toneType: 'num',
				pattern: 'pinyin'
			})[0];

			if (!raw || /[a-z]/i.test(raw) === false) return null;

			const clean = normalize(raw);
			const tone = extractTone(raw);
			const parts = detectFinal(clean);
			return parts ? { char, raw, clean, tone, fin: parts.final, ini: parts.initial } : null;
		};

		const registerBank = () => {
			if (!window.pinyinPro || !window.pinyinPro.pinyin) return new Map();
			const source = typeof window.getRhymeBank === 'function' ? window.getRhymeBank() : window.RHYME_CHAR_BANK || [];
			const map = new Map();
			for (const item of source) {
				// 将多字词拆成单个字符
				const chars = Array.from(item);
				for (const ch of chars) {
					const info = toInfo(ch);
					if (!info) continue;
					const key = `${info.fin}-${info.tone}`;
					if (!map.has(key)) map.set(key, []);
					// 避免重复添加相同的字
					if (!map.get(key).includes(ch)) {
						map.get(key).push(ch);
					}
				}
			}
			return map;
		};

		const thirteenTracks = [
			{ name: '发花辙', finals: ['a', 'ia', 'ua'] },
			{ name: '梭波辙', finals: ['o', 'e', 'uo'] },
			{ name: '乜斜辙', finals: ['ie', 'ue', 've'] },
			{ name: '言前辙', finals: ['an', 'ian', 'uan', 'van', 'üan'] },
			{ name: '人辰辙-深', finals: ['en', 'un'] },
			{ name: '人辰辙-亲', finals: ['in', 'vn', 'ün'] },
			{ name: '江阳辙', finals: ['ang', 'iang', 'uang'] },
			{ name: '中东辙', finals: ['eng', 'ing', 'ong', 'iong'] },
			{ name: '一七辙', finals: ['i', 'v', 'er', 'ü', 'i-flat', 'i-retro'] },
			{ name: '姑苏辙', finals: ['u'] },
			{ name: '怀来辙', finals: ['ai', 'uai'] },
			{ name: '灰堆辙', finals: ['ei', 'ui', 'uei'] },
			{ name: '遥条辙', finals: ['ao', 'iao'] },
			{ name: '油求辙', finals: ['ou', 'iu', 'iou'] }
		];

		const coreRhymes = ['a', 'o', 'e', 'i', 'u', 'v', 'ai', 'ei', 'ao', 'ou', 'an', 'en', 'ang', 'eng', 'ong'];

		const finalToChunk = (fin) => {
			// 根据韵母的第一个字符或核心部分进行分片
			for (let i = 0; i < thirteenTracks.length; i++) {
				if (thirteenTracks[i].finals.includes(fin)) return `chunk_${i}`;
			}
			return 'chunk_other';
		};

		// 松紧分级：
		// 0（严格）：同韵同调（区分平翘舌、前后鼻音）
		// 1（中等）：同调，但韵母放宽（不分平翘舌，不分前后鼻音）
		// 2（最松）：韵母放宽（同上），且不限制声调
		const getLoosenessTier = (value) => {
			if (value >= 0.67) return 2;
			if (value >= 0.34) return 1;
			return 0;
		};

		// 兼容旧字典键值的扩展映射
		const legacyKeyMap = {
			'i-flat': ['i'],
			'i-retro': ['i'],
			'i': [
				'i', 
				'z-retroflex', 'c-retroflex', 's-retroflex',
				'zh-retroflex-e', 'ch-retroflex-e', 'sh-retroflex-e', 'r-retroflex-e',
				'j-palatal', 'q-palatal', 'x-palatal'
			],
			'u': [
				'u',
				// 旧代码把 zu, cu, su 也归为 retroflex，所以也要查这些
				'z-retroflex', 'c-retroflex', 's-retroflex',
				'zh-retroflex-e', 'ch-retroflex-e', 'sh-retroflex-e', 'r-retroflex-e'
			]
		};

		// 从字典查询拼音组合对应的词组（新算法）
		// 使用最后两个字的韵脚为查询条件，返回所有相关匹配
		const queryDict = async (infos, looseness) => {
			if (!infos || infos.length === 0) return null;
			
			// 修改：不再强制只取最后两个字，而是根据输入长度决定
			// 用户要求：查询条件跟生成结果一样，字数由用户输入决定
			let queryInfos = infos;
			
			// 验证韵脚信息的有效性
			const validInfos = queryInfos.filter(info => info.fin && info.fin !== '-');
			if (validInfos.length === 0) return null;
			
			const tier = getLoosenessTier(looseness);
			const allowToneRelax = tier >= 2;
			
			// 生成所有可能的查询键变体
			const generateQueryKeys = (infos) => {
				const keys = [];
				const recurse = (index, current) => {
					if (index === infos.length) {
						keys.push(current.join('_'));
						return;
					}
					const info = infos[index];
					// Tier 2: 所有字都允许声调放宽（因为只处理最后两个字，组合数可控）
					// Tier 0/1: 必须严格匹配声调
					const toneVariants = allowToneRelax ? [1,2,3,4] : [info.tone];
					
					// 获取该韵母的所有变体
					const finVariants = buildFinalVariants(info.fin, tier);
					
					// 扩展为旧字典的键值
					const expandedVariants = new Set();
					for (const v of finVariants) {
						expandedVariants.add(v);
						if (legacyKeyMap[v]) {
							legacyKeyMap[v].forEach(k => expandedVariants.add(k));
						}
					}

					for (const fin of expandedVariants) {
						for (const tone of toneVariants) {
							const keyPart = `${fin}${tone}`;
							recurse(index + 1, [...current, keyPart]);
						}
					}
				};
				recurse(0, []);
				return keys;
			};
			
			const queryKeys = generateQueryKeys(validInfos);
			const queryVariantSet = new Set();
			queryKeys.forEach(k => {
				buildKeyVariants(k).forEach(v => {
					const encoded = encodeKey(v);
					if (bloomFilter.mightContain(encoded)) {
						queryVariantSet.add(encoded);
					}
				});
			});
			
			// 在字典中搜索所有可能的匹配
			const matchedByWordCount = {};
			const sourceLength = infos.length;
			
			// 优化方案：移动端优先，只使用精准哈希查询，彻底移除全字典扫描
			// 从 IndexedDB 中逐个查询命中的变体
			for (const qk of queryVariantSet) {
				const candidates = await getFromDB(qk);
				if (candidates && Array.isArray(candidates)) {
					for (const phrase of candidates) {
						const phraseLen = Array.from(phrase).length;
						if (!matchedByWordCount[phraseLen]) {
							matchedByWordCount[phraseLen] = [];
						}
						if (!matchedByWordCount[phraseLen].includes(phrase)) {
							matchedByWordCount[phraseLen].push(phrase);
						}
					}
				}
			}
			
			// 也从自定义词库中查询
			try {
				const customStr = localStorage.getItem('CUSTOM_RHYME_BANK');
				if (customStr) {
					const customBank = JSON.parse(customStr);
					if (Array.isArray(customBank)) {
						for (const phrase of customBank) {
							if (typeof phrase === 'string' && phrase.length > 0) {
								// 检查自定义词是否以查询key结尾
								const phraseInfos = Array.from(phrase).map(ch => toInfo(ch)).filter(Boolean);
								if (phraseInfos.length > 0) {
									const lastTwoPhrase = phraseInfos.length >= 2 ? phraseInfos.slice(-2) : phraseInfos;
													const phraseKeyParts = lastTwoPhrase.map(info => `${info.fin}${info.tone}`);
													const phraseKey = phraseKeyParts.join('_');
													const phraseVariants = buildKeyVariants(phraseKey);
													const hit = phraseVariants.some(v => queryVariantSet.has(v));
									
													if (hit) {
										const phraseLen = Array.from(phrase).length;
										if (!matchedByWordCount[phraseLen]) {
											matchedByWordCount[phraseLen] = [];
										}
										if (!matchedByWordCount[phraseLen].includes(phrase)) {
											matchedByWordCount[phraseLen].push(phrase);
										}
									}
								}
							}
						}
					}
				}
			} catch (e) {
				console.warn('自定义词库读取失败:', e);
			}
			
		// 返回分类结果
		let sortedLengths = Object.keys(matchedByWordCount).map(Number).sort((a, b) => a - b);
		
		const sameLengthResults = [];
		const moreLengthResults = [];
		const lessLengthResults = [];
		
		// 先添加相同字数的匹配
		const sameLengthCandidates = sortedLengths.filter(len => len === sourceLength);
		for (const len of sameLengthCandidates) {
			sameLengthResults.push(...matchedByWordCount[len]);
		}
		
		// 收集少一字的匹配
		const targetLess = sourceLength - 1;
		if (targetLess >= 1 && matchedByWordCount[targetLess]) {
			lessLengthResults.push(...matchedByWordCount[targetLess]);
		}
		
		// 如果没有相同字数的匹配，且源字数大于2，尝试降级查询
		if (sameLengthResults.length === 0 && sourceLength > 2) {
			let currentLength = sourceLength - 1;
			while (currentLength >= 2 && sameLengthResults.length === 0) {
				// 取末尾 currentLength 个字重新查询
				const shorterInfos = infos.slice(-currentLength);
				const shorterResult = await queryDict(shorterInfos, looseness);
				
				if (shorterResult && shorterResult.sameLength && shorterResult.sameLength.length > 0) {
					sameLengthResults.push(...shorterResult.sameLength);
					devLog(`降级查询成功：从 ${sourceLength} 字降到 ${currentLength} 字`);
					break;
				}
				
				currentLength--;
			}
		}
		
		// 然后添加所有字数更多的匹配
		const moreLengthCandidates = sortedLengths.filter(len => len > sourceLength);
		for (const len of moreLengthCandidates) {
			moreLengthResults.push(...matchedByWordCount[len]);
		}
		
		return {
			sameLength: sameLengthResults.length > 0 ? sameLengthResults : null,
			lessLength: lessLengthResults.length > 0 ? lessLengthResults : null,
			moreLengths: moreLengthResults.length > 0 ? moreLengthResults : null
		};
	};

		const buildFinalVariants = (fin, tier) => {
			// Tier 0: 严格模式，完全匹配
			if (tier === 0) return [fin];

			// Tier 1 & 2: 宽松模式 (合并平翘舌，合并前后鼻音)
			
			// 1. 前后鼻音合并：言前(an) + 江阳(ang)
			const groupAnAng = ['an', 'ian', 'uan', 'van', 'üan', 'ang', 'iang', 'uang'];
			if (groupAnAng.includes(fin)) return groupAnAng;

			// 2. 前后鼻音合并：
			// 人辰-深(en/un) + 中东-eng(eng/ong) -> 实际上 en 和 eng 押韵更近
			const groupEnEng = ['en', 'un', 'eng', 'ong', 'iong'];
			if (groupEnEng.includes(fin)) return groupEnEng;

			// 人辰-亲(in/vn/ün) + 中东-ing(ing) -> 实际上 in 和 ing 押韵更近
			const groupInIng = ['in', 'vn', 'ün', 'ing'];
			if (groupInIng.includes(fin)) return groupInIng;

			// 3. 其他情况（包括 i-flat/i-retro 归为一七辙），使用十三辙
			const track = thirteenTracks.find(t => t.finals.includes(fin));
			return track ? track.finals : [fin];
		};

		const normalizeSpecialFinal = (fin) => {
			// 旧逻辑残留，现在直接返回 fin 即可
			return fin;
		};

		// 检查候选短语是否逐字匹配源词的韵脚（优先保证每个字的韵脚一致）
		const phraseFitsSource = (phrase, sourceInfos, looseness) => {
			const tier = getLoosenessTier(looseness);
			const allowToneRelax = tier >= 2; // Tier 2 忽略声调
			const chars = Array.from(phrase);
			
			// 修改：始终从末尾对齐进行比较
			// 无论是长词还是短词，都比较末尾对应的字
			const len = Math.min(chars.length, sourceInfos.length);
			const srcOffset = sourceInfos.length - len;
			const phraseOffset = chars.length - len;

			// 定义特殊声母集合（平翘舌）
			const specialInitials = ['zh', 'ch', 'sh', 'r', 'z', 'c', 's'];

			for (let i = 0; i < len; i++) {
				const src = sourceInfos[srcOffset + i];
				const ch = chars[phraseOffset + i];
				const pInfo = ch ? toInfo(ch) : null;
				if (!src || !pInfo || !src.fin || src.fin === '-') return false;
				
				// 检查韵母兼容性
				let rhymeOk = false;
				if (tier === 0) {
					// 严格：必须完全相同
					rhymeOk = (src.fin === pInfo.fin);
				} else {
					// 宽松：检查是否在同一个变体组中
					const variants = buildFinalVariants(src.fin, tier);
					rhymeOk = variants.includes(pInfo.fin);
				}
				
				if (!rhymeOk) return false;
				
				// 检查声调
				// Tier 0 & 1: 声调必须相同
				// Tier 2: 声调可不同
				const toneOk = allowToneRelax || (src.tone === pInfo.tone);
				if (!toneOk) return false;

				// --- 新增：声母类型过滤 ---
				// 规则：如果源字声母不是平翘舌音，则匹配字声母也不能是平翘舌音。
				// 避免“自律(l)”匹配到“世世(sh)”这种听感差异巨大的情况。
				const srcIsSpecial = specialInitials.includes(src.ini);
				const matchIsSpecial = specialInitials.includes(pInfo.ini);
				
				if (!srcIsSpecial && matchIsSpecial) {
					return false;
				}
				// -------------------------
			}
			return true;
		};

		const pickFromMap = (fin, originalTone, looseness, forceTone = null) => {
			const tier = getLoosenessTier(looseness);
			
			// 对于特殊标记的韵母，不进行扩展
			let finalsToTry;
			if (fin.includes('-')) {
				finalsToTry = [fin];
			} else {
				finalsToTry = buildFinalVariants(fin, tier);
			}

			let targetTones = [];
			if (forceTone !== null) {
				targetTones = [Number(forceTone)];
			} else {
				// Tier 2: 所有声调
				// Tier 0/1: 严格声调
				if (tier >= 2) {
					targetTones = [1, 2, 3, 4];
				} else {
					targetTones = [originalTone];
				}
			}

			const candidates = [];
			for (const f of finalsToTry) {
				for (const t of targetTones) {
					candidates.push(...(bankMap.get(`${f}-${t}`) || []));
				}
			}

			// 如果最松档且没有结果，才尝试忽略声调
			if (candidates.length === 0 && tier >= 2 && !forceTone) {
				// 已经在上面处理了所有声调，这里不需要额外逻辑，除非 bankMap 缺失
			}

			if (candidates.length === 0) return null;
			return candidates[Math.floor(Math.random() * candidates.length)];
		};

		const processAI = async (src, infos, looseness) => {
			const apiKey = localStorage.getItem('GEMINI_API_KEY');
			const proxy = localStorage.getItem('GEMINI_PROXY') || '';
			if (!apiKey) {
				alert('请先输入 Gemini API Key');
				return;
			}

			const output = document.getElementById('output');
			const badges = document.getElementById('badges');
			const matchedResultsList = document.getElementById('matchedResultsList');
			
			output.innerHTML = '<i class="ri-robot-2-line"></i> AI 正在思考中...';
			badges.innerHTML = '<div class="badge"><i class="ri-time-line"></i> 请稍候</div>';
			matchedResultsList.innerHTML = '';

			const tier = getLoosenessTier(looseness);
			const rhymeInfo = infos.map(i => `${i.char}(${i.fin}${i.tone})`).join(' ');
			
			const prompt = `你是一个深谙中文韵律的顶级作词人，现在需要根据一个词寻找押韵的词汇。

					【输入词】：${src}
					【韵部】：${rhymeInfo}
					【等级】：Tier ${tier}（0为死押、音调和韵脚要一致，1为通押、优先音调一致，2为谐音、音调可以不一致）

						任务：
						1. 生成至少 25 个与输入词语押韵的中文词语。
						2. 生成的词语不能和输入词语相同。生成的词语要包含不限于常用词语、网络词语、成语、歌词等，但优先显示生成的歌词和常见词语。
						3. 生成字数相同的词语25个,但也要生成15个包含字数更多尾部押韵的词语。生成更多字数的押韵词语要尽量多样化，尾部不可以重复。
						4. 必须严格遵守韵脚和音调要求（除非等级Tier较高，音调为1,2,3,4）。
						5. 只返回词语列表，用空格分隔，不要有任何解释。
						6. 严禁生拼硬凑，绝对禁止生成“死词”（如：XX机、XX门等无意义组合）。`;

			try {
				let baseUrl = 'https://generativelanguage.googleapis.com';
				if (proxy) {
					baseUrl = proxy.replace(/\/$/, '');
				}

				const response = await fetch(`${baseUrl}/v1beta/models/gemini-3-flash-preview:generateContent?key=${apiKey}`, {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						contents: [{ parts: [{ text: prompt }] }]
					})
				});

				if (!response.ok) {
					const errorData = await response.json().catch(() => ({}));
					throw new Error(errorData.error?.message || `HTTP ${response.status}`);
				}

				const data = await response.json();
				const text = data.candidates[0].content.parts[0].text.trim();
				// 使用正则提取所有中文字符串，过滤掉非中文和原词
				const aiWords = (text.match(/[\u4e00-\u9fa5]+/g) || []).filter(w => w && w !== src);

				if (aiWords.length === 0) {
					throw new Error('AI 未返回有效的押韵词，请重试。');
				}

				// 将 AI 结果分类，模拟 dictResult 结构
				const sourceLength = Array.from(src).length;
				const dictResult = {
					sameLength: aiWords.filter(w => Array.from(w).length === sourceLength),
					lessLength: aiWords.filter(w => Array.from(w).length < sourceLength),
					moreLengths: aiWords.filter(w => Array.from(w).length > sourceLength)
				};

				// 构造 infos 结构，用于渲染表格
				const firstAiWord = dictResult.sameLength[0] || aiWords[0] || src;
				const aiChars = Array.from(firstAiWord);
				const newInfos = infos.map((info, idx) => {
					const char = aiChars[idx] || info.char;
					return {
						...info,
						generated: char,
						candidates: aiWords.filter(w => Array.from(w).length === sourceLength).map(w => Array.from(w)[idx]).filter(Boolean),
						locked: false
					};
				});

				currentInfos = newInfos;
				currentDictResult = dictResult;
				render(newInfos, firstAiWord, dictResult, src, true);

				// 填充更多匹配结果列表
				const seen = new Set();
				[...dictResult.lessLength, ...dictResult.moreLengths].forEach(phrase => {
					if (seen.has(phrase)) return;
					seen.add(phrase);
					const span = document.createElement('span');
					span.style.cssText = 'padding: 6px 12px; background: var(--card); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-size: 14px;';
					span.textContent = phrase;
					matchedResultsList.appendChild(span);
				});
				document.getElementById('matchedResults').style.display = 'block';

			} catch (e) {
				console.error('AI 生成失败:', e);
				let errorMsg = e.message;
				if (errorMsg === 'Failed to fetch') {
					errorMsg = '网络连接失败 (Failed to fetch)。如果你在特殊网络环境下，请尝试在设置中配置 API 代理地址。';
				}
				output.textContent = '❌ AI 生成失败: ' + errorMsg;
				badges.innerHTML = '';
			} finally {
				// Remove loading state
				const goBtn = document.getElementById('go');
				setTimeout(() => {
					goBtn.classList.remove('loading');
				}, 100);
			}
		};

		const process = async () => {
		const goBtn = document.getElementById('go');
		const src = document.getElementById('source').value.trim();
		const looseness = Number(document.getElementById('looseness').value);
		const isAiMode = document.getElementById('aiMode').checked;
		const pingzeFilter = document.querySelector('input[name="pingze"]:checked')?.value || 'all';
		
		// Show loading state
		goBtn.classList.add('loading');
		if (!goBtn.querySelector('.btn-text')) {
			goBtn.innerHTML = '<span class="btn-text">' + goBtn.textContent + '</span>';
		}
		
		if (!pinyinReady || !window.pinyinPro || !window.pinyinPro.pinyin) {
			goBtn.classList.remove('loading');
			render([], 'pinyin-pro 未加载，请检查网络或稍后重试', null, '');
			return;
		}
		if (bankMap.size === 0) bankMap = registerBank();
		if (!src) {
			goBtn.classList.remove('loading');
			render([], '等待输入...', null, '');
			return;
		}

		// Build new infos but preserve locked/forced settings from previous run
			const oldInfos = Array.isArray(currentInfos) ? currentInfos.slice() : [];
			
			// 先提取所有字符的拼音信息，记录基准声调
			const tempInfos = Array.from(src).map((ch) => {
				const info = toInfo(ch);
				if (!info) return { char: ch, raw: '-', tone: '-', baseTone: '-', fin: '-', forcedTone: null };
				return { ...info, baseTone: info.tone, forcedTone: null };
			});

			// 应用用户在解析表中选择的强制声调
			const tempInfosWithOverrides = tempInfos.map((info, idx) => {
				const old = oldInfos[idx];
				const forcedTone = old && old.forcedTone !== null ? old.forcedTone : null;
				const tone = forcedTone !== null ? forcedTone : info.baseTone;
				return { ...info, tone, forcedTone };
			});

			if (isAiMode) {
				processAI(src, tempInfosWithOverrides, looseness);
				return;
			}
			
			// 尝试从字典查询整句
			const dictResult = await queryDict(tempInfosWithOverrides, looseness);
			currentDictResult = dictResult; // 保存到全局变量供render使用
			
			// 获取用户输入的原词（用于排除）
			const userInput = tempInfosWithOverrides.map(info => info.char).join('');
			
			// 显示匹配结果（字数更多的）
			const matchedResults = document.getElementById('matchedResults');
			const matchedResultsList = document.getElementById('matchedResultsList');
			
			// 首先清空列表
			matchedResultsList.innerHTML = '';
			
			// 收集所有匹配词
			let allMatchedPhrases = [];
			const seen = new Set();
			const collectPhrase = (phrase) => {
				if (seen.has(phrase)) return;
				if (phrase === userInput) return;
				if (phrase.includes(userInput)) return;
				seen.add(phrase);
				allMatchedPhrases.push(phrase);
			};

			if (dictResult) {
				// 少一字匹配
				if (dictResult.lessLength && dictResult.lessLength.length > 0) {
					let filteredLess = dictResult.lessLength.filter(phrase => phraseFitsSource(phrase, tempInfosWithOverrides, looseness));
					let displayLess = filteredLess.length > 0 ? filteredLess : dictResult.lessLength;
					if (looseness >= 1.0 && pingzeFilter !== 'all') {
						displayLess = filterByPingZe(displayLess, pingzeFilter);
					}
					displayLess.forEach(collectPhrase);
				}

				// 更多字匹配
				if (dictResult.moreLengths && dictResult.moreLengths.length > 0) {
					let filteredMore = dictResult.moreLengths.filter(phrase => phraseFitsSource(phrase, tempInfosWithOverrides, looseness));
					let displayMore = filteredMore.length > 0 ? filteredMore : dictResult.moreLengths;
					if (looseness >= 1.0 && pingzeFilter !== 'all') {
						displayMore = filterByPingZe(displayMore, pingzeFilter);
					}
					
					const groupedByLength = {};
					for (const phrase of displayMore) {
						const len = Array.from(phrase).length;
						if (!groupedByLength[len]) groupedByLength[len] = [];
						groupedByLength[len].push(phrase);
					}
					
					for (const [len, phrases] of Object.entries(groupedByLength)) {
						const lengthNum = parseInt(len);
						if (lengthNum <= 2) {
							phrases.forEach(collectPhrase);
							continue;
						}
						const groupedByTail = {};
						for (const phrase of phrases) {
							const chars = Array.from(phrase);
							const tail = chars.length >= 2 ? chars.slice(-2).join('') : phrase;
							if (!groupedByTail[tail]) groupedByTail[tail] = [];
							groupedByTail[tail].push(phrase);
						}
						for (const [tail, phrasesWithSameTail] of Object.entries(groupedByTail)) {
							const randomIndex = Math.floor(Math.random() * phrasesWithSameTail.length);
							collectPhrase(phrasesWithSameTail[randomIndex]);
						}
					}
				}
			}
			
			// 始终显示容器
			matchedResults.style.display = 'block';
			
			if (allMatchedPhrases.length > 0) {
				const container = document.getElementById('matchedResultsList');
				container.innerHTML = '';
				allMatchedPhrases.forEach(phrase => {
					const span = document.createElement('span');
					span.className = 'virtual-item';
					span.textContent = phrase;
					container.appendChild(span);
				});
			}
			
			if (dictResult) {
				devLog('字典查询成功');
				devLog('相同字数结果:', dictResult.sameLength);
				devLog('更长字数结果:', dictResult.moreLengths);
			}
			
			let newInfos;
			// 检查 dictResult 是否是多个候选项（字符串数组）
			if (dictResult && dictResult.sameLength && Array.isArray(dictResult.sameLength) && dictResult.sameLength.length > 0) {
				// 优先逐字韵脚匹配（所有字都要满足源词的韵母/声调规则）；若无，再退回“末两字”匹配结果
				const tier = getLoosenessTier(looseness);
				const allowToneRelax = tier >= 2;
				const strongMatches = dictResult.sameLength.filter((phrase) => 
					// 排除与用户输入相同的词和包含用户输入的词
					phrase !== userInput && !phrase.includes(userInput) && phraseFitsSource(phrase, tempInfosWithOverrides, looseness)
				);
				const ranked = strongMatches.length > 0 ? strongMatches : [];
				
				if (ranked.length === 0) {
					// 字典查询没有通过过滤的结果，退回到逐字选择的模式
					newInfos = tempInfosWithOverrides.map((info, idx) => {
						if (info.fin === '-') {
							return { ...info, generated: info.char, locked: false, forcedTone: oldInfos[idx] && oldInfos[idx].forcedTone !== undefined ? oldInfos[idx].forcedTone : null };
						}
						// 保留锁定状态
						if (oldInfos[idx] && oldInfos[idx].locked) {
							return { 
								...info, 
								generated: oldInfos[idx].generated || info.char, 
								locked: true, 
								forcedTone: oldInfos[idx].forcedTone || null 
							};
						}
						const candidate = pickFromMap(info.fin, info.tone, looseness);
						return { 
							...info, 
							generated: candidate || info.char, 
							locked: false, 
							forcedTone: oldInfos[idx] && oldInfos[idx].forcedTone !== undefined ? oldInfos[idx].forcedTone : null 
						};
					});
				} else {
					const firstPhrase = Array.from(ranked[0]); // 第一条作为默认生成
					
					newInfos = tempInfosWithOverrides.map((info, idx) => {
						// 保留锁定状态
						if (oldInfos[idx] && oldInfos[idx].locked) {
							return { 
								...info, 
								generated: oldInfos[idx].generated || info.char, 
								candidates: [], // 锁定状态下不显示候选项
								locked: true, 
								forcedTone: oldInfos[idx].forcedTone || null 
							};
						}
						
						// 为这个位置的所有候选词收集第 idx 个字符
						const charCandidates = [];
						for (const phrase of ranked) {
							const chars = Array.from(phrase);
							if (idx < chars.length) {
								const char = chars[idx];
								if (!charCandidates.includes(char)) {
									charCandidates.push(char);
								}
							}
						}
						
					// 排除会使结果与用户输入相同的字符
					const filteredCandidates = charCandidates.filter(char => {
						// 构建假设选择该字符后的完整词（使用firstPhrase作为基准）
						const testPhrase = firstPhrase.map((c, i) => 
							i === idx ? char : c
						).join('');
						return testPhrase !== userInput;
					});
					
				devLog(`位置 ${idx}: candidates = ${JSON.stringify(filteredCandidates)}`);
					let selectedChar = firstPhrase[idx];
					// 如果 firstPhrase 会导致与用户输入相同，使用过滤后的候选
					const wouldMatchInput = firstPhrase.join('') === userInput;
					if (wouldMatchInput && filteredCandidates.length > 0) {
						selectedChar = filteredCandidates[0];
					} else if (wouldMatchInput && charCandidates.length > 0) {
						// 如果过滤后没有候选，尝试从原始候选中找一个不同的
						const differentChar = charCandidates.find(c => c !== info.char);
						selectedChar = differentChar || charCandidates[0];
					}
					
					return { 
						...info, 
						generated: selectedChar, 
						candidates: filteredCandidates.length > 0 ? filteredCandidates : charCandidates,
						locked: false, 
						forcedTone: oldInfos[idx] && oldInfos[idx].forcedTone !== undefined ? oldInfos[idx].forcedTone : null 
					};
				});
			}
		} else {
			// 字典查询失败,使用原逻辑
			newInfos = tempInfosWithOverrides.map((info, idx) => {
				if (info.fin === '-') {
					return { ...info, generated: info.char, locked: false, forcedTone: oldInfos[idx] && oldInfos[idx].forcedTone !== undefined ? oldInfos[idx].forcedTone : null };
				}
				// 保留锁定状态
				if (oldInfos[idx] && oldInfos[idx].locked) {
					return { 
						...info, 
						generated: oldInfos[idx].generated || info.char, 
						locked: true, 
						forcedTone: oldInfos[idx].forcedTone || null 
					};
				}
				const candidate = pickFromMap(info.fin, info.tone, looseness);
				return { 
					...info, 
					generated: candidate || info.char, 
					locked: false, 
					forcedTone: oldInfos[idx] && oldInfos[idx].forcedTone !== undefined ? oldInfos[idx].forcedTone : null 
				};
			});
		}
		
		currentInfos = newInfos;
		render(currentInfos, currentInfos.map((i) => i.generated).join(''), currentDictResult, userInput);
		
		// Remove loading state
		setTimeout(() => {
			goBtn.classList.remove('loading');
		}, 100);
	};

	// 更新单个字符的声调或韵母
	const updateSingleChar = async (index, newTone, newFinal) => {
		if (!Array.isArray(currentInfos) || index < 0 || index >= currentInfos.length) return;
		
		const isAiMode = document.getElementById('aiMode').checked;

		// 克隆当前信息数组
		const updatedInfos = currentInfos.map((info, idx) => {
			if (idx === index) {
				const updated = { ...info };
				
				// 更新声调
				if (newTone !== null && newTone !== undefined) {
					updated.forcedTone = newTone;
					updated.tone = newTone;
				}
				
				// 更新韵母
				if (newFinal !== null && newFinal !== undefined) {
					updated.forcedFinal = newFinal;
					updated.fin = newFinal;
				}
				
				return updated;
			}
			return info;
		});

		if (isAiMode) {
			const src = document.getElementById('source').value.trim();
			processAI(src, updatedInfos, Number(document.getElementById('looseness').value));
			return;
		}
		
		// 使用更新后的信息重新查询
		const looseness = Number(document.getElementById('looseness').value);
		const dictResult = await queryDict(updatedInfos, looseness);
		currentDictResult = dictResult;
		
		// 获取用户输入的原词
		const userInput = updatedInfos.map(info => info.char).join('');
		
		// 重新生成结果
		let newInfos;
		if (dictResult && dictResult.sameLength && Array.isArray(dictResult.sameLength) && dictResult.sameLength.length > 0) {
			const tier = getLoosenessTier(looseness);
			const strongMatches = dictResult.sameLength.filter((phrase) => 
				phrase !== userInput && !phrase.includes(userInput) && phraseFitsSource(phrase, updatedInfos, looseness)
			);
			const ranked = strongMatches.length > 0 ? strongMatches : [];
			
			if (ranked.length > 0) {
				const firstPhrase = Array.from(ranked[0]);
				newInfos = updatedInfos.map((info, idx) => {
					if (currentInfos[idx] && currentInfos[idx].locked) {
						return { 
							...info, 
							generated: currentInfos[idx].generated || info.char, 
							locked: true
						};
					}
					return {
						...info,
						generated: firstPhrase[idx] || info.char,
						locked: false
					};
				});
			} else {
				newInfos = updatedInfos.map((info, idx) => {
					if (currentInfos[idx] && currentInfos[idx].locked) {
						return { 
							...info, 
							generated: currentInfos[idx].generated || info.char, 
							locked: true
						};
					}
					const candidate = pickFromMap(info.fin, info.tone, looseness);
					return {
						...info,
						generated: candidate || info.char,
						locked: false
					};
				});
			}
		} else {
			// 字典查询失败，使用原逻辑
			newInfos = updatedInfos.map((info, idx) => {
				if (info.fin === '-') {
					return { ...info, generated: info.char, locked: false };
				}
				if (currentInfos[idx] && currentInfos[idx].locked) {
					return { 
						...info, 
						generated: currentInfos[idx].generated || info.char, 
						locked: true
					};
				}
				const candidate = pickFromMap(info.fin, info.tone, looseness);
				return {
					...info,
					generated: candidate || info.char,
					locked: false
				};
			});
		}
		
		currentInfos = newInfos;
		render(currentInfos, currentInfos.map((i) => i.generated).join(''), currentDictResult, userInput);
	};

	const render = (infos, text, dictResult, userInput, skipFilter = false) => {
			// 获取平仄过滤选项
			const pingzeFilter = document.querySelector('input[name="pingze"]:checked')?.value || 'all';
			const looseness = Number(document.getElementById('looseness').value);
			
			// 更新右侧生成结果面板
			const output = document.getElementById('output');
			const badges = document.getElementById('badges');
			
			if (output) {
				// 显示相同字数的所有匹配结果（来自dictResult）
				let results = [];
				
				// 先显示当前生成结果（排除与用户输入相同的词）
				if (text && text !== userInput) {
					results.push(text);
				}
				
				// 然后添加字典中的相同字数结果（必须通过phraseFitsSource过滤）
				if (dictResult && dictResult.sameLength && Array.isArray(dictResult.sameLength)) {
					for (const phrase of dictResult.sameLength) {
						// 排除用户输入和已经在结果中的词
						if (phrase !== text && phrase !== userInput && !results.includes(phrase)) {
							// 严格检查该词是否真正符合源词的韵脚要求
							if (skipFilter || phraseFitsSource(phrase, infos, looseness)) {
								results.push(phrase);
							}
						}
					}
				}
				
				// 应用平仄过滤（仅在最松时有效）
				if (looseness >= 1.0 && pingzeFilter !== 'all') {
					results = filterByPingZe(results, pingzeFilter);
				}
				
				// 用制表符分隔显示所有结果在同一行
				const resultText = results.join('\t');
				output.style.whiteSpace = 'pre-wrap';
				output.style.wordBreak = 'keep-all';
				output.style.overflowWrap = 'normal';
				output.textContent = resultText || '-';
				output.style.fontFamily = 'var(--font-family, "DM Sans", "Segoe UI", system-ui, -apple-system, sans-serif)';
				output.style.fontSize = '18px';
				output.style.fontWeight = '500';
				output.style.lineHeight = '1.8';
				output.style.letterSpacing = '0.5px';
			}
			
			if (badges) {
				badges.innerHTML = '';
				if (text) {
					const badge = document.createElement('div');
					badge.className = 'badge';
					badge.innerHTML = `<i class="ri-sparkling-line"></i> ${text.length} 字`;
					badges.appendChild(badge);
				}
			}
			
			// 更新下方详情表格
			const body = document.getElementById('detailBody');
			body.innerHTML = '';
			infos.forEach((i, index) => {
				const tr = document.createElement('tr');
				
				// 第一列：原字
				const td1 = document.createElement('td');
				td1.textContent = i.char;
				tr.appendChild(td1);
				
				// 第二列：拼音
				const td2 = document.createElement('td');
				td2.textContent = i.raw || '-';
				tr.appendChild(td2);
				
				// 第三列：声调
				const td3 = document.createElement('td');
				td3.textContent = i.tone || '-';
				tr.appendChild(td3);
				
				// 第四列：韵母+声调控制
				const td4 = document.createElement('td');
				
				// 韵母输入框（可编辑）
				const finInput = document.createElement('input');
				finInput.type = 'text';
				finInput.value = i.fin || '-';
				finInput.dataset.index = index;
				finInput.className = 'fin-input';
				
				// 监听韵母变化
				finInput.addEventListener('change', (e) => {
					const idx = Number(e.target.dataset.index);
					const newFinal = e.target.value.trim() || '-';
					updateSingleChar(idx, null, newFinal);
				});
				
				td4.appendChild(finInput);
				td4.appendChild(document.createTextNode(' '));
				
				if (i.tone !== '-') {
					const select = document.createElement('select');
					select.className = 'tone-select';
					select.dataset.index = index;
					
					const opt0 = document.createElement('option');
					opt0.value = '';
					opt0.textContent = '原';
					opt0.selected = i.forcedTone === null;
					select.appendChild(opt0);
					
					for (let tone = 1; tone <= 4; tone++) {
						const opt = document.createElement('option');
						opt.value = tone;
						opt.textContent = tone;
						opt.selected = i.forcedTone == tone;
						select.appendChild(opt);
					}
					
					select.addEventListener('change', (e) => {
						const idx = Number(e.target.dataset.index);
						const val = e.target.value ? Number(e.target.value) : null;
						updateSingleChar(idx, val, null);
					});
					
					td4.appendChild(select);
				}
				tr.appendChild(td4);
				
				body.appendChild(tr);
			});

			// 触发动画
			if (window.triggerResultAnimation) window.triggerResultAnimation();
		};

		const loadOnlineDict = async () => {
			const btn = document.getElementById('loadDictBtn');
			const originalText = btn.textContent;
			btn.innerHTML = '<i class="ri-loader-4-line"></i> 加载中...';
			btn.disabled = true;

			try {
				if (typeof Worker === 'undefined') {
					throw new Error('您的浏览器不支持 Web Worker，无法加载大词库');
				}

				const worker = new Worker('./dict-worker.js');
				worker.onmessage = async (event) => {
					const { type, message, data, percent, progress } = event.data;

					if (type === 'progress') {
						btn.textContent = `${message} ${percent ? percent + '%' : ''}`;
					} else if (type === 'parsing') {
						btn.textContent = `解析存储中: ${progress || 0}%`;
					} else if (type === 'success') {
						const { chars } = data;
						// 更新本地存储状态（仅用于显示）
						localStorage.setItem('ONLINE_DICT_TIME', Date.now().toString());
						localStorage.setItem('ONLINE_DICT_CACHE', JSON.stringify(chars.slice(0, 100))); // 仅存少量用于显示数量
						localStorage.setItem('ONLINE_DICT_COUNT', chars.length.toString());
						
						// 重建索引
						const keys = await getAllKeysFromDB();
						bloomFilter = new BloomFilter(keys.length * 10, 3);
						keys.forEach(k => bloomFilter.add(k));
						
						btn.textContent = `✓ 已加载 ${chars.length} 字`;
						btn.style.background = 'rgba(34, 211, 238, 0.2)';
						window.dictLoaded = true;
						
						setTimeout(() => {
							btn.innerHTML = `✅ 已缓存 ${chars.length} 字`;
							btn.disabled = false;
							btn.style.background = '';
							updateDictStatus();
						}, 2000);
						worker.terminate();
					} else if (type === 'error') {
						throw new Error(message);
					}
				};

				worker.onerror = (err) => {
					throw err;
				};

				worker.postMessage({
					action: 'loadAndProcess',
					payload: { dictSources: [{ name: '优化词库', url: './dict_optimized.json' }] }
				});

			} catch (err) {
				console.error('词库加载失败:', err);
				btn.textContent = `✗ ${err.message || '加载失败'}`;
				btn.style.background = 'rgba(239, 68, 68, 0.2)';
				setTimeout(() => {
					btn.textContent = originalText;
					btn.disabled = false;
					btn.style.background = '';
				}, 3000);
			}
		};

		const loadOnlineDictFallback = async () => {
			// Synchronous fallback for browsers without Web Worker support
			const btn = document.getElementById('loadDictBtn');
			const originalText = btn.textContent;

			try {
				const response = await fetch('./dict_optimized.json', {
					method: 'GET',
					headers: { 'Accept': 'application/json' }
				});

				if (!response.ok) throw new Error('HTTP ' + response.status);

				btn.innerHTML = '<i class="ri-loader-4-line"></i> 解析中...';
				const data = await response.json();
				const chars = new Set();
				let stats = {
					totalStrings: 0,
					totalChars: 0,
					uniqueChars: 0,
					categories: 0
				};

				if (Array.isArray(data)) {
					stats.categories = 1;
					data.forEach((item, idx) => {
						if (idx % 5000 === 0) {
							btn.innerHTML = `<i class="ri-loader-4-line"></i> 解析中... ${Math.round((idx / data.length) * 100)}%`;
						}
						if (typeof item === 'string') {
							stats.totalStrings++;
							Array.from(item).forEach(ch => {
								if (/[\u4e00-\u9fa5]/.test(ch)) {
									stats.totalChars++;
									chars.add(ch);
								}
							});
						}
					});
				} else if (data && typeof data === 'object') {
					const entries = Object.entries(data);
					stats.categories = entries.length;
					entries.forEach(([, value], idx) => {
						if (idx % 500 === 0) {
							btn.innerHTML = `<i class="ri-loader-4-line"></i> 解析中... ${Math.round((idx / entries.length) * 100)}%`;
						}
						if (Array.isArray(value)) {
							stats.totalStrings += value.length;
							value.forEach(item => {
								if (typeof item === 'string') {
									Array.from(item).forEach(ch => {
										if (/[\u4e00-\u9fa5]/.test(ch)) {
											stats.totalChars++;
											chars.add(ch);
										}
									});
								}
							});
						}
					});
				}

				const charArray = Array.from(chars);
				stats.uniqueChars = charArray.length;
				
				localStorage.setItem('ONLINE_DICT_CACHE', JSON.stringify(charArray));
				localStorage.setItem('ONLINE_DICT_TIME', Date.now().toString());
				localStorage.setItem('ONLINE_DICT_SOURCE', '本地优化词库');
				localStorage.setItem('ONLINE_DICT_STATS', JSON.stringify(stats));

				if (window.refreshRhymeBank) window.refreshRhymeBank();
				bankMap = registerBank();

				btn.textContent = `✓ 已加载 ${charArray.length} 字`;
				btn.style.background = 'rgba(34, 211, 238, 0.2)';

				const dictStatus = document.getElementById('dictStatus');
				const dictStatusText = document.getElementById('dictStatusText');
				dictStatus.style.display = 'block';
				
				let statusText = `<i class="ri-book-open-line"></i> 词库：${charArray.length} 个唯一汉字（本地优化词库）`;
				if (stats.totalChars > 0) {
					statusText += ` | 数据统计：${stats.categories.toLocaleString()} 分类，${stats.totalStrings.toLocaleString()} 条目，${stats.totalChars.toLocaleString()} 字符（去重前）`;
				}
				statusText += ` | ${new Date().toLocaleString('zh-CN')}`;
				dictStatusText.textContent = statusText;

				setTimeout(() => {
					btn.innerHTML = `✅️ 已缓存 ${charArray.length} 字`;
					btn.disabled = false;
					btn.style.background = '';
				}, 1500);
			} catch (err) {
				console.error('词库加载失败:', err);
				btn.textContent = '✗ 加载失败';
				btn.style.background = 'rgba(239, 68, 68, 0.2)';

				setTimeout(() => {
					btn.textContent = originalText;
					btn.disabled = false;
					btn.style.background = '';
				}, 3000);
			}
		};

		// Debounce 函数
		const debounce = (func, delay) => {
			let timeoutId;
			return (...args) => {
				clearTimeout(timeoutId);
				timeoutId = setTimeout(() => func(...args), delay);
			};
		};

		const init = () => {
			document.getElementById('go').addEventListener('click', process);
			const sourceInput = document.getElementById('source');
			
			// 当输入框内容变化时，清除加载状态
			sourceInput.addEventListener('input', () => {
				const goBtn = document.getElementById('go');
				goBtn.classList.remove('loading');
			});
			
			// 键盘快捷键
			sourceInput.addEventListener('keydown', (e) => {
				if (e.ctrlKey && e.key === 'Enter') process();
			});

			const loosenInput = document.getElementById('looseness');
			const loosenessSelector = document.getElementById('loosenessSelector');
			const segmentBtns = loosenessSelector.querySelectorAll('.segment-btn');
			
			const pingzeFilterContainer = document.getElementById('pingzeFilterContainer');
			
			// 监听分段选择器点击
			segmentBtns.forEach(btn => {
				btn.addEventListener('click', () => {
					// 移除旧的 active 类
					segmentBtns.forEach(b => b.classList.remove('active'));
					// 添加新的 active 类
					btn.classList.add('active');
					// 更新隐藏的 input 值
					const val = btn.dataset.value;
					loosenInput.value = val;
					
					// 触发更新
					updatePingzeFilterVisibility();
					triggerRecalc();
				});
			});
			
			// 监听韵脚宽松度变化，显示/隐藏平仄过滤器
			const updatePingzeFilterVisibility = () => {
				const looseness = Number(loosenInput.value);
				if (looseness >= 1.0) {
					pingzeFilterContainer.style.display = 'block';
				} else {
					pingzeFilterContainer.style.display = 'none';
				}
			};
			
			const triggerRecalc = () => {
				if (document.getElementById('source').value.trim()) process();
			};
			// 使用 debounce，延迟 300ms 后再执行查询
			const debouncedRecalc = debounce(triggerRecalc, 250);
			
			// 初始化平仄过滤器可见性
			updatePingzeFilterVisibility();
			
			// 监听平仄过滤选项变化
			const pingzeRadios = document.querySelectorAll('input[name="pingze"]');
			pingzeRadios.forEach(radio => {
				radio.addEventListener('change', () => {
					if (document.getElementById('source').value.trim()) {
						process();
					}
				});
			});

			const loadDictBtn = document.getElementById('loadDictBtn');
			loadDictBtn.addEventListener('click', loadOnlineDict);

			const clearDictBtn = document.getElementById('clearDictBtn');
			clearDictBtn.addEventListener('click', () => {
				if (!confirm('确定要清理本地缓存的词库数据吗？清理后需要重新加载词库才能正常使用。')) return;
				
				const originalText = clearDictBtn.innerHTML;
				clearDictBtn.innerHTML = '<i class="ri-loader-4-line"></i> 清理中...';
				clearDictBtn.disabled = true;

				const worker = new Worker('./dict-worker.js');
				worker.onmessage = (event) => {
					if (event.data.type === 'clearSuccess') {
						localStorage.removeItem('ONLINE_DICT_TIME');
						localStorage.removeItem('ONLINE_DICT_COUNT');
						localStorage.removeItem('ONLINE_DICT_CACHE');
						localStorage.removeItem('ONLINE_DICT_STATS');
						
						bloomFilter = new BloomFilter();
						window.dictLoaded = false;
						
						clearDictBtn.innerHTML = '<i class="ri-check-line"></i> 已清理';
						updateDictStatus();
						
						setTimeout(() => {
							clearDictBtn.innerHTML = originalText;
							clearDictBtn.disabled = false;
						}, 2000);
						worker.terminate();
					}
				};
				worker.postMessage({ action: 'clearCache' });
			});

			// AI Mode Logic
			const aiModeCheckbox = document.getElementById('aiMode');
			const dictWarning = document.getElementById('dictWarning');
			const aiSettingsModal = document.getElementById('aiSettingsModal');
			const openAiSettingsBtn = document.getElementById('openAiSettings');
			const closeAiSettingsBtn = document.getElementById('closeAiSettings');
			const saveAiSettingsBtn = document.getElementById('saveAiSettings');
			const geminiApiKeyInput = document.getElementById('geminiApiKey');
			const geminiProxyInput = document.getElementById('geminiProxy');

			// Load saved AI settings
			const savedAiMode = localStorage.getItem('AI_MODE') === 'true';
			const savedApiKey = localStorage.getItem('GEMINI_API_KEY') || '';
			const savedProxy = localStorage.getItem('GEMINI_PROXY') || '';
			
			aiModeCheckbox.checked = savedAiMode;
			geminiApiKeyInput.value = savedApiKey;
			geminiProxyInput.value = savedProxy;
			if (savedAiMode) {
				dictWarning.style.display = 'none';
				loadDictBtn.style.display = 'none';
			}

			aiModeCheckbox.addEventListener('change', (e) => {
				const isAi = e.target.checked;
				dictWarning.style.display = isAi ? 'none' : 'block';
				loadDictBtn.style.display = isAi ? 'none' : 'inline-flex';
				localStorage.setItem('AI_MODE', isAi);
				if (isAi && !localStorage.getItem('GEMINI_API_KEY')) {
					aiSettingsModal.classList.add('active');
				}
			});

			// Modal Logic
			openAiSettingsBtn.addEventListener('click', () => {
				aiSettingsModal.classList.add('active');
			});

			const closeModal = () => {
				aiSettingsModal.classList.remove('active');
			};

			closeAiSettingsBtn.addEventListener('click', closeModal);
			aiSettingsModal.addEventListener('click', (e) => {
				if (e.target === aiSettingsModal) closeModal();
			});

			saveAiSettingsBtn.addEventListener('click', () => {
				localStorage.setItem('GEMINI_API_KEY', geminiApiKeyInput.value.trim());
				localStorage.setItem('GEMINI_PROXY', geminiProxyInput.value.trim());
				closeModal();
			});

			// Check if online dict is already loaded
			const updateDictStatus = () => {
				const cachedTime = localStorage.getItem('ONLINE_DICT_TIME');
				const dictStatus = document.getElementById('dictStatus');
				const dictStatusText = document.getElementById('dictStatusText');
				
				if (cachedTime) {
					const count = localStorage.getItem('ONLINE_DICT_COUNT') || '7000+';
					const source = localStorage.getItem('ONLINE_DICT_SOURCE') || '核心词库';
					const date = new Date(Number(cachedTime));
					
					loadDictBtn.innerHTML = `✅ 已缓存 ${count} 字`;
					dictStatus.style.display = 'block';
					dictStatusText.textContent = `📖 词库：${count} 个汉字（${source}） | ${date.toLocaleString('zh-CN')}`;
				}
			};
			
			updateDictStatus();

			// Expose debug utilities to window for console access
			window.dictDebug = {
				showStats: function() {
					const stats = localStorage.getItem('ONLINE_DICT_STATS');
					const cache = localStorage.getItem('ONLINE_DICT_CACHE');
					const source = localStorage.getItem('ONLINE_DICT_SOURCE');
					const time = localStorage.getItem('ONLINE_DICT_TIME');
					
					console.clear();
					console.log('%c词库统计信息', 'font-size:16px; font-weight:bold; color:#7c3aed');
					console.log('来源:', source || '未加载');
					console.log('加载时间:', time ? new Date(parseInt(time)).toLocaleString('zh-CN') : '未加载');
					
					if (cache) {
						const chars = JSON.parse(cache);
						console.log('唯一汉字数:', chars.length);
					}
					
					if (stats) {
						const s = JSON.parse(stats);
						console.table({
							'分类数': s.categories.toLocaleString(),
							'条目数（字符串）': s.totalStrings.toLocaleString(),
							'字符总数（去重前）': s.totalChars.toLocaleString(),
							'唯一汉字数': s.uniqueChars.toLocaleString(),
							'重复度': ((1 - s.uniqueChars / s.totalChars) * 100).toFixed(2) + '%'
						});
					} else {
						console.log('（无详细统计，可重新加载词库获取）');
					}
				},
				
				cacheSize: function() {
					let total = 0;
					for (let key in localStorage) {
						if (key.startsWith('ONLINE_DICT_')) {
							const size = localStorage[key].length;
							console.log(`${key}: ${(size / 1024).toFixed(2)} KB`);
							total += size;
						}
					}
					console.log(`总计: ${(total / 1024 / 1024).toFixed(2)} MB`);
				}
			};
			
			console.log('%c💡 提示', 'color:#22d3ee; font-weight:bold');
			console.log('在控制台执行以下命令查看词库信息：');
			console.log('  • window.dictDebug.showStats()  - 显示详细统计');
			console.log('  • window.dictDebug.cacheSize()  - 显示缓存大小');

			loadScriptSeq([...cdnList], (err, url) => {
				if (err) {
					setOutputStatus('pinyin-pro 未加载，已尝试备用 CDN。可手动下载 pinyin-pro.js 放在同目录。');
					return;
				}
				pinyinReady = true;
				bankMap = registerBank();
				setOutputStatus(`pinyin-pro 已加载 (${url})，可点击生成。`);
			});
			
			// 立即加载优化字典
			loadDict();

			// 启动页面基础动画
			if (window.startMainAnimations) {
				window.startMainAnimations();
			}
		};

		init();
	</script>
	<script>
		if ('serviceWorker' in navigator) {
			window.addEventListener('load', () => {
				navigator.serviceWorker.register('./service-worker.js').catch((err) => {
					console.warn('Service worker registration failed', err);
				});
			});
		}
	</script>
	<!-- Help Button -->
	<button class="help-btn" id="helpTriggerBtn" title="使用说明">?</button>

	<!-- Modal -->
	<div class="modal-overlay" id="helpModalOverlay">
		<div class="modal">
			<div class="modal-header">
				<h2>使用说明</h2>
				<button class="modal-close" id="helpCloseBtn">&times;</button>
			</div>
						<div class="modal-content">
				<h3> 基本功能</h3>
				<ul>
					<li><strong>加载词库：</strong>使用前请务必点击<strong>「加载词库」</strong>按钮</li>
					<li><strong>输入文字：</strong>在左侧输入框输入需要押韵的词语</li>
					<li><strong>生成押韵：</strong>点击<strong>「生成押韵」</strong>按钮，系统会自动分析并生成押韵词汇</li>
					<li><strong>韵脚宽松度：</strong>调节滑块可以放宽押韵条件，最宽松时可以选择显示平仄</li>
				</ul>
				
				<h3> 高级设置</h3>
				<ul>
					<li><strong>AI 押韵模式：</strong>启用后需要自行填入 Gemini API Key</li>
					<li><strong>支持的模型：</strong>目前 AI 模式暂时只支持 Gemini</li>
				</ul>
				
				<h3> 使用技巧</h3>
				<ul>
					<li>建议先从较严格的韵脚开始尝试，再逐步放宽条件</li>
					<li>可以多尝试不同的输入词语，探索更多押韵可能性</li>
					<li>AI 模式可以生成更有创意的押韵词汇，但需要联网使用</li>
				</ul>
				
				<h3>ℹ 关于</h3>
				<p>这是一个简单的中文押韵生成器，旨在帮助创作者寻找灵感。</p>
				<p style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border); text-align: center;">
					爷不肉，蛋卷制造 2026
				</p>
			</div>
		</div>
	</div>

	<script>
		const helpTriggerBtn = document.getElementById('helpTriggerBtn');
		const helpModalOverlay = document.getElementById('helpModalOverlay');
		const helpCloseBtn = document.getElementById('helpCloseBtn');

		function toggleHelpModal(show) {
			if (show) {
				helpModalOverlay.classList.add('active');
			} else {
				helpModalOverlay.classList.remove('active');
			}
		}

		helpTriggerBtn.addEventListener('click', () => toggleHelpModal(true));
		helpCloseBtn.addEventListener('click', () => toggleHelpModal(false));
		
		// Click outside to close
		helpModalOverlay.addEventListener('click', (e) => {
			if (e.target === helpModalOverlay) {
				toggleHelpModal(false);
			}
		});
		
		// Escape key to close
		document.addEventListener('keydown', (e) => {
			if (e.key === 'Escape' && helpModalOverlay.classList.contains('active')) {
				toggleHelpModal(false);
			}
		});
	</script>
</body>
</html>
