<!DOCTYPE html>
<html lang="zh">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>ä¸­æ–‡æŠ¼éŸµç”Ÿæˆå™¨</title>
	<link rel="preconnect" href="https://unpkg.com" />
	<style>
		:root {
			--bg: #0f172a;
			--panel: #111827;
			--card: #0b1220;
			--text: #e2e8f0;
			--muted: #94a3b8;
			--accent: #7c3aed;
			--accent-2: #22d3ee;
			--border: #1f2937;
			--radius: 16px;
		}

		* {
			box-sizing: border-box;
		}

		body {
			margin: 0;
			min-height: 100vh;
			background: radial-gradient(circle at 20% 20%, rgba(124, 58, 237, 0.2), transparent 35%),
				radial-gradient(circle at 80% 10%, rgba(34, 211, 238, 0.2), transparent 30%),
				radial-gradient(circle at 50% 80%, rgba(56, 189, 248, 0.15), transparent 35%),
				var(--bg);
			color: var(--text);
			font-family: "DM Sans", "Segoe UI", system-ui, -apple-system, sans-serif;
			display: flex;
			align-items: center;
			justify-content: center;
			padding: 40px 16px 64px;
		}

		.shell {
			width: min(1000px, 100%);
			background: linear-gradient(145deg, rgba(255, 255, 255, 0.03), rgba(255, 255, 255, 0));
			border: 1px solid var(--border);
			border-radius: var(--radius);
			box-shadow: 0 30px 80px rgba(0, 0, 0, 0.35);
			overflow: hidden;
		}

		header {
			padding: 28px 32px 12px;
		}

		h1 {
			margin: 0;
			font-size: 28px;
			letter-spacing: 0.4px;
		}

		p.subtitle {
			margin: 8px 0 0;
			color: var(--muted);
			font-size: 14px;
		}

		main {
			display: grid;
			grid-template-columns: 1.1fr 0.9fr;
			gap: 20px;
			padding: 0 32px 28px;
		}

		@media (max-width: 900px) {
			main {
				grid-template-columns: 1fr;
			}
		}

		.panel {
			background: var(--panel);
			border: 1px solid var(--border);
			border-radius: calc(var(--radius) - 4px);
			padding: 20px;
			position: relative;
			overflow: hidden;
		}

		.panel::before {
			content: "";
			position: absolute;
			inset: 0;
			background: radial-gradient(circle at 30% 30%, rgba(124, 58, 237, 0.08), transparent 40%);
			pointer-events: none;
		}

		label {
			display: flex;
			align-items: center;
			justify-content: space-between;
			gap: 12px;
			font-weight: 600;
			margin-bottom: 10px;
		}

		textarea,
		input[type="text"] {
			width: 100%;
			background: var(--card);
			border: 1px solid var(--border);
			border-radius: 12px;
			padding: 14px;
			color: var(--text);
			font-size: 16px;
			transition: border 0.2s ease, box-shadow 0.2s ease;
			resize: vertical;
			min-height: 120px;
		}

		textarea:focus,
		input[type="text"]:focus {
			border-color: var(--accent);
			outline: none;
			box-shadow: 0 0 0 2px rgba(124, 58, 237, 0.25);
		}

		.controls {
			display: flex;
			flex-wrap: wrap;
			gap: 10px;
			margin-top: 12px;
			align-items: center;
		}

		.btn {
			background: linear-gradient(135deg, var(--accent), var(--accent-2));
			border: none;
			color: white;
			padding: 12px 18px;
			border-radius: 12px;
			font-weight: 700;
			cursor: pointer;
			transition: transform 0.15s ease, box-shadow 0.15s ease;
			box-shadow: 0 10px 25px rgba(124, 58, 237, 0.25);
		}

		.btn:hover {
			transform: translateY(-1px);
			box-shadow: 0 15px 30px rgba(124, 58, 237, 0.35);
		}

		.btn:active {
			transform: translateY(0);
		}

		.btn.ghost {
			background: transparent;
			color: var(--text);
			border: 1px solid var(--border);
			box-shadow: none;
		}

		.btn.ghost:hover {
			border-color: var(--accent);
			box-shadow: 0 0 0 2px rgba(124, 58, 237, 0.2);
		}

		.hint {
			color: var(--muted);
			font-size: 12px;
			margin-top: 6px;
		}

		.output {
			font-size: 22px;
			line-height: 1.6;
			min-height: 120px;
			word-break: break-all;
			margin-bottom: 10px;
		}

		.badge-row {
			display: flex;
			flex-wrap: wrap;
			gap: 8px;
			margin-top: 10px;
			font-size: 12px;
			color: var(--muted);
		}

		.badge {
			padding: 6px 10px;
			border-radius: 999px;
			background: rgba(124, 58, 237, 0.15);
			border: 1px solid rgba(124, 58, 237, 0.35);
			color: #d8b4fe;
			display: inline-flex;
			align-items: center;
			gap: 6px;
		}

		table {
			width: 100%;
			border-collapse: collapse;
			font-size: 13px;
		}

		th,
		td {
			border-bottom: 1px solid var(--border);
			padding: 8px;
			text-align: left;
			color: var(--muted);
		}

		th {
			color: var(--text);
			font-weight: 700;
		}

		.pill {
			display: inline-flex;
			align-items: center;
			gap: 4px;
			padding: 4px 10px;
			border-radius: 10px;
			background: rgba(34, 211, 238, 0.12);
			color: #a5f3fc;
			border: 1px solid rgba(34, 211, 238, 0.35);
			font-weight: 600;
			cursor: pointer;
			user-select: none;
			transition: all 0.2s ease;
		}

		.lock-btn {
			background: transparent;
			border: none;
			color: var(--text);
			padding: 0;
			border-radius: 0;
			cursor: pointer;
			font-size: 12px;
			line-height: 1;
		}

		.lock-btn.locked {
			background: transparent;
			border-color: transparent;
		}

		.pill:hover {
			background: rgba(34, 211, 238, 0.2);
			box-shadow: 0 0 10px rgba(34, 211, 238, 0.15);
		}

		.pill:active {
			transform: scale(0.95);
		}

		.small {
			font-size: 12px;
			color: var(--muted);
		}

		.footer {
			padding: 12px 32px 22px;
			color: var(--muted);
			font-size: 12px;
		}
	</style>
</head>
<body>
	<div class="shell">
		<header>
			<h1>è¿ç»­æŠ¼åŒéŸ³è°ƒçš„éŸµè„šç”Ÿæˆå™¨</h1>
			<p class="subtitle">è¾“å…¥è¯è¯­ï¼Œè‡ªåŠ¨æå–æ‹¼éŸ³ã€å£°è°ƒä¸éŸµæ¯ï¼Œç”Ÿæˆæ¯ä¸ªå­—åŒå£°è°ƒåŒéŸµæ¯çš„æŠ¼éŸµå­—ä¸²ã€‚</p>
		</header>

		<main>
			<section class="panel">
				<label for="source">
					è¯·è¾“å…¥è¦æŠ¼éŸµçš„è¯è¯­ï¼š
				</label>
				<textarea id="source" placeholder="ç¤ºä¾‹ï¼šåºŸå£³"></textarea>

				<div class="controls">
					<button class="btn" id="go">ç”ŸæˆæŠ¼éŸµ</button>
					<a class="btn ghost" href="custom.html">è‡ªå®šä¹‰è¯åº“</a>
					<button class="btn ghost" id="loadDictBtn" title="ä»åœ¨çº¿è¯åº“åŠ è½½æ›´å¤šæ±‰å­—">ğŸ“š åŠ è½½è¯åº“</button>
					<label class="small" for="looseness">éŸµè„šå®½æ¾åº¦ï¼ˆ0=ä¸¥æ ¼ï¼Œ1=æœ€æ¾ï¼‰</label>
					<input type="range" id="looseness" min="0" max="1" step="0.05" value="0.15" />
				</div>
				<div class="hint">0 ä¸¥æ ¼ï¼šåŒéŸµåŒè°ƒï¼›0.34-0.66 ä¸­ç­‰ï¼šéŸµæ¯æ”¾å®½ï¼ˆå‰åé¼»éŸ³ç­‰ï¼‰ä½†å£°è°ƒç›¸åŒï¼›â‰¥0.67 æœ€æ¾ï¼šè¿›ä¸€æ­¥æ”¾å®½éŸµæ¯ï¼ˆiang/angç­‰ï¼‰ï¼Œæœ€åæ‰å¿½ç•¥å£°è°ƒã€‚</div>
			</section>

		</main>

		<section class="panel" style="margin: 0 32px 20px;">
			<label style="margin-bottom: 14px;">è§£æè¯¦æƒ…</label>
			<table>
				<thead>
					<tr>
						<th>åŸå­—</th>
						<th>æ‹¼éŸ³</th>
						<th>å£°è°ƒ</th>
						<th>éŸµæ¯</th>
					</tr>
				</thead>
				<tbody id="detailBody"></tbody>
			</table>
		</section>

		<section class="panel" style="margin: 0 32px 20px;">
			<div id="matchedResults" style="padding: 12px; background: rgba(34, 211, 238, 0.05); border: 1px solid var(--border); border-radius: 8px; display: none;">
				<div style="font-weight: 600; margin-bottom: 8px; color: var(--accent-2);">åŒ¹é…ç»“æœï¼š</div>
				<div id="matchedResultsList" style="display: flex; flex-wrap: wrap; gap: 8px;"></div>
			</div>
			<div id="dictStatus" style="margin-top: 12px; padding: 8px 12px; background: rgba(124, 58, 237, 0.08); border-radius: 8px; font-size: 12px; color: var(--muted); display: none;">
				<span id="dictStatusText"></span>
			</div>
		</section>

		<div class="footer">åŸºäº pinyin-pro è§£æã€‚ç‚¹å‡»"ğŸ“š åŠ è½½è¯åº“"å¯ä»åœ¨çº¿è¯å…¸è·å–7000+æ±‰å­—ï¼Œæ•°æ®ç¼“å­˜åœ¨æœ¬åœ°ï¼Œå¯ç¦»çº¿ä½¿ç”¨ã€‚</div>
	</div>

	<script src="./data.js"></script>
	<script>
		const cdnList = [
			'https://unpkg.com/pinyin-pro@3.27.0/dist/index.js',
			'https://cdn.jsdelivr.net/npm/pinyin-pro@3.27.0/dist/index.js',
			// å¦‚æœéœ€è¦æœ¬åœ°å¤‡ç”¨ï¼Œå°† pinyin-pro.umd.js æ”¾åœ¨åŒç›®å½•å¹¶å–æ¶ˆä¸‹ä¸€è¡Œæ³¨é‡Š
			// './pinyin-pro.umd.js'
		];

		const loadScriptSeq = (list, cb) => {
			if (!list.length) return cb(new Error('å…¨éƒ¨ CDN åŠ è½½å¤±è´¥'));
			const [url, ...rest] = list;
			const s = document.createElement('script');
			s.src = url;
			s.onload = () => cb(null, url);
			s.onerror = () => {
				s.remove();
				loadScriptSeq(rest, cb);
			};
			document.head.appendChild(s);
		};

		const setOutputStatus = (msg) => {
			// Output element removed
		};
		const finals = [
			'iong', 'uang', 'iang', 'ueng', 'uan', 'ian', 'uen', 'iao', 'uai', 'ang', 'eng', 'ing', 'ong', 'ai', 'ei', 'ao', 'ou', 'an', 'en', 'in', 'un', 'vn', 'ia', 'ua', 'uo', 'ie', 'ue', 'ui', 'er', 'a', 'o', 'e', 'i', 'u', 'v'
		];

		let bankMap = new Map();
		let pinyinReady = false;
		let currentInfos = [];
		let dict = null; // ä¼˜åŒ–å­—å…¸
		let locks = [];

		// åŠ è½½ä¼˜åŒ–å­—å…¸
		const loadDict = async () => {
			try {
				const resp = await fetch('dict_optimized.json');
				const text = await resp.text();
				dict = JSON.parse(text);
				console.log('å­—å…¸åŠ è½½æˆåŠŸ,å…±', Object.keys(dict).length, 'æ¡');
			} catch(e) {
				console.error('å­—å…¸åŠ è½½å¤±è´¥:', e);
			}
		};

		const normalize = (p) => p.replace(/\d/g, '');

		const extractTone = (p) => {
			const m = p.match(/(\d)/);
			return m ? Number(m[1]) : 0;
		};

		const detectFinal = (p) => {
			for (const f of finals) {
				if (p.endsWith(f)) return f;
			}
			return null;
		};

		const toInfo = (char) => {
			const raw = window.pinyinPro.pinyin(char, {
				type: 'array',
				toneType: 'num',
				pattern: 'pinyin'
			})[0];

			if (!raw || /[a-z]/i.test(raw) === false) return null;

			const clean = normalize(raw);
			const tone = extractTone(raw);
			const fin = detectFinal(clean);
			return fin ? { char, raw, clean, tone, fin } : null;
		};

		const registerBank = () => {
			if (!window.pinyinPro || !window.pinyinPro.pinyin) return new Map();
			const source = typeof window.getRhymeBank === 'function' ? window.getRhymeBank() : window.RHYME_CHAR_BANK || [];
			const map = new Map();
			for (const item of source) {
				// å°†å¤šå­—è¯æ‹†æˆå•ä¸ªå­—ç¬¦
				const chars = Array.from(item);
				for (const ch of chars) {
					const info = toInfo(ch);
					if (!info) continue;
					const key = `${info.fin}-${info.tone}`;
					if (!map.has(key)) map.set(key, []);
					// é¿å…é‡å¤æ·»åŠ ç›¸åŒçš„å­—
					if (!map.get(key).includes(ch)) {
						map.get(key).push(ch);
					}
				}
			}
			return map;
		};

		const nasalPairs = [
			['ang', 'an'],
			['eng', 'en'],
			['ing', 'in'],
			['uan', 'an'],
			['uai', 'ai'],
			['iao', 'ao'],
			['ai', 'ei'],
			['an', 'ian'],
			['iang', 'ian']
		];

		const looseExtraPairs = [
			['iang', 'ang']
		];

		// æ¾ç´§åˆ†çº§ï¼ˆå£°è°ƒä¼˜å…ˆï¼‰ï¼š
		// 0ï¼ˆä¸¥æ ¼ï¼‰ï¼šå£°è°ƒå®Œå…¨ç›¸åŒ + éŸµæ¯å®Œå…¨ç›¸åŒ
		// 0.5ï¼ˆä¸­ç­‰ï¼‰ï¼šå£°è°ƒå®Œå…¨ç›¸åŒ + éŸµæ¯å…è®¸å‰åé¼»éŸ³åˆå¹¶ï¼ˆang/anã€iang/ianç­‰ï¼‰
		// 1ï¼ˆæœ€æ¾ï¼‰ï¼šå£°è°ƒç›¸åŒ + éŸµæ¯è¿›ä¸€æ­¥åˆå¹¶ï¼ˆiang/angï¼‰ï¼Œè‹¥æ‰¾ä¸åˆ°å†å¿½ç•¥å£°è°ƒ
		const getLoosenessTier = (value) => {
			if (value >= 0.67) return 2;
			if (value >= 0.34) return 1;
			return 0;
		};

		// ä»å­—å…¸æŸ¥è¯¢æ‹¼éŸ³ç»„åˆå¯¹åº”çš„è¯ç»„ï¼ˆæ–°ç®—æ³•ï¼‰
		// ä½¿ç”¨æœ€åä¸¤ä¸ªå­—çš„éŸµè„šä¸ºæŸ¥è¯¢æ¡ä»¶ï¼Œè¿”å›æ‰€æœ‰ç›¸å…³åŒ¹é…
		const queryDict = (infos) => {
			if (!infos || infos.length === 0) return null;
			
			// è·å–æœ€åä¸¤ä¸ªå­—çš„éŸµè„š
			let lastTwoInfos = [];
			if (infos.length >= 2) {
				// å–æœ€åä¸¤ä¸ªå­—
				lastTwoInfos = infos.slice(-2);
			} else if (infos.length === 1) {
				// å¦‚æœåªæœ‰ä¸€ä¸ªå­—ï¼Œå°±ç”¨è¿™ä¸€ä¸ªå­—
				lastTwoInfos = infos;
			}
			
			// éªŒè¯éŸµè„šä¿¡æ¯çš„æœ‰æ•ˆæ€§
			const validInfos = lastTwoInfos.filter(info => info.fin && info.fin !== '-');
			if (validInfos.length === 0) return null;
			
			// æ„å»ºæŸ¥è¯¢key
			const keyParts = validInfos.map(info => `${info.fin}${info.tone}`);
			const queryKey = keyParts.join('_');
			
			// åœ¨å­—å…¸ä¸­æœç´¢æ‰€æœ‰å¯èƒ½çš„åŒ¹é…
			const matchedByWordCount = {};
			const sourceLength = infos.length;
			
			// éå†ä¼˜åŒ–å­—å…¸å¯»æ‰¾åŒ¹é…
			if (dict) {
				for (const [dictKey, candidates] of Object.entries(dict)) {
					// æ£€æŸ¥æŸ¥è¯¢keyæ˜¯å¦åœ¨dictKeyä¸­ç»“å°¾åŒ¹é…
					if (dictKey.endsWith(queryKey)) {
						if (candidates && Array.isArray(candidates)) {
							for (const phrase of candidates) {
								const phraseLen = Array.from(phrase).length;
								
								// æŒ‰å­—æ•°åˆ†ç±»
								if (!matchedByWordCount[phraseLen]) {
									matchedByWordCount[phraseLen] = [];
								}
								matchedByWordCount[phraseLen].push(phrase);
							}
						}
					}
				}
			}
			
			// ä¹Ÿä»è‡ªå®šä¹‰è¯åº“ä¸­æŸ¥è¯¢
			try {
				const customStr = localStorage.getItem('CUSTOM_RHYME_BANK');
				if (customStr) {
					const customBank = JSON.parse(customStr);
					if (Array.isArray(customBank)) {
						for (const phrase of customBank) {
							if (typeof phrase === 'string' && phrase.length > 0) {
								// æ£€æŸ¥è‡ªå®šä¹‰è¯æ˜¯å¦ä»¥æŸ¥è¯¢keyç»“å°¾
								const phraseInfos = Array.from(phrase).map(ch => toInfo(ch)).filter(Boolean);
								if (phraseInfos.length > 0) {
									const lastTwoPhrase = phraseInfos.length >= 2 ? phraseInfos.slice(-2) : phraseInfos;
									const phraseKeyParts = lastTwoPhrase.map(info => `${info.fin}${info.tone}`);
									const phraseKey = phraseKeyParts.join('_');
									
									if (phraseKey === queryKey) {
										const phraseLen = Array.from(phrase).length;
										if (!matchedByWordCount[phraseLen]) {
											matchedByWordCount[phraseLen] = [];
										}
										if (!matchedByWordCount[phraseLen].includes(phrase)) {
											matchedByWordCount[phraseLen].push(phrase);
										}
									}
								}
							}
						}
					}
				}
			} catch (e) {
				console.warn('è‡ªå®šä¹‰è¯åº“è¯»å–å¤±è´¥:', e);
			}
			
		// è¿”å›é¡ºåºï¼š
		// 1. å…ˆè¿”å›æ‰€æœ‰ç›¸åŒå­—æ•°çš„åŒ¹é…
		// 2. ç„¶åè¿”å›æ‰€æœ‰å­—æ•°æ›´å¤šçš„åŒ¹é…ï¼ˆæŒ‰å­—æ•°å‡åºï¼‰
		// 3. ä¸è¿”å›å­—æ•°æ›´å°‘çš„åŒ¹é…
		let sortedLengths = Object.keys(matchedByWordCount).map(Number).sort((a, b) => a - b);
		
		const result = [];
		
		// å…ˆæ·»åŠ ç›¸åŒå­—æ•°çš„åŒ¹é…
		const sameLengthCandidates = sortedLengths.filter(len => len === sourceLength);
		for (const len of sameLengthCandidates) {
			result.push(...matchedByWordCount[len]);
		}
		
		// ç„¶åæ·»åŠ æ‰€æœ‰å­—æ•°æ›´å¤šçš„åŒ¹é…
		const moreLengthCandidates = sortedLengths.filter(len => len > sourceLength);
		for (const len of moreLengthCandidates) {
			result.push(...matchedByWordCount[len]);
		}
		
		return result.length > 0 ? result : null;
	};

		const buildFinalVariants = (fin, tier) => {
			const variants = new Set([fin]);
			if (tier >= 1) {
				for (const [a, b] of nasalPairs) {
					if (a === fin || b === fin) {
						variants.add(a);
						variants.add(b);
					}
				}
			}
			if (tier >= 2) {
				for (const [a, b] of looseExtraPairs) {
					if (a === fin || b === fin) {
						variants.add(a);
						variants.add(b);
					}
				}
			}
			return Array.from(variants);
		};

		const pickFromMap = (fin, originalTone, looseness, forceTone = null) => {
			const tier = getLoosenessTier(looseness);
			const finalsToTry = buildFinalVariants(fin, tier);

			let targetTones = [];
			if (forceTone !== null) {
				targetTones = [Number(forceTone)];
			} else {
				// å£°è°ƒä¼˜å…ˆï¼š0å’Œ1éƒ½ä¿æŒåŸå£°è°ƒï¼Œ2æ‰ä¼šå°è¯•æ”¾å¼€
				targetTones = [originalTone];
			}

			const candidates = [];
			for (const f of finalsToTry) {
				for (const t of targetTones) {
					candidates.push(...(bankMap.get(`${f}-${t}`) || []));
				}
			}

			// å¦‚æœæœ€æ¾æ¡£ä¸”æ²¡æœ‰ç»“æœï¼Œæ‰å°è¯•å¿½ç•¥å£°è°ƒ
			if (candidates.length === 0 && tier >= 2 && !forceTone) {
				for (const f of finalsToTry) {
					for (let t = 1; t <= 4; t++) {
						candidates.push(...(bankMap.get(`${f}-${t}`) || []));
					}
				}
			}

			if (candidates.length === 0) return null;
			return candidates[Math.floor(Math.random() * candidates.length)];
		};

		const process = () => {
			const src = document.getElementById('source').value.trim();
			const looseness = Number(document.getElementById('looseness').value);
			if (!pinyinReady || !window.pinyinPro || !window.pinyinPro.pinyin) {
				render([], 'pinyin-pro æœªåŠ è½½ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–ç¨åé‡è¯•');
				return;
			}
			if (bankMap.size === 0) bankMap = registerBank();
			if (!src) {
				render([], 'ç­‰å¾…è¾“å…¥...');
				return;
			}

			// Build new infos but preserve locked/forced settings from previous run
			const oldInfos = Array.isArray(currentInfos) ? currentInfos.slice() : [];
			
			// å…ˆæå–æ‰€æœ‰å­—ç¬¦çš„æ‹¼éŸ³ä¿¡æ¯ï¼Œè®°å½•åŸºå‡†å£°è°ƒ
			const tempInfos = Array.from(src).map((ch) => {
				const info = toInfo(ch);
				if (!info) return { char: ch, raw: '-', tone: '-', baseTone: '-', fin: '-', forcedTone: null };
				return { ...info, baseTone: info.tone, forcedTone: null };
			});

			// åº”ç”¨ç”¨æˆ·åœ¨è§£æè¡¨ä¸­é€‰æ‹©çš„å¼ºåˆ¶å£°è°ƒ
			const tempInfosWithOverrides = tempInfos.map((info, idx) => {
				const old = oldInfos[idx];
				const forcedTone = old && old.forcedTone !== null ? old.forcedTone : null;
				const tone = forcedTone !== null ? forcedTone : info.baseTone;
				return { ...info, tone, forcedTone };
			});
			
			// å°è¯•ä»å­—å…¸æŸ¥è¯¢æ•´å¥
			const dictResult = queryDict(tempInfosWithOverrides);
			
			// æ˜¾ç¤ºåŒ¹é…ç»“æœ
			const matchedResults = document.getElementById('matchedResults');
			const matchedResultsList = document.getElementById('matchedResultsList');
			if (dictResult && dictResult.length > 0) {
				matchedResults.style.display = 'block';
				matchedResultsList.innerHTML = '';
				dictResult.forEach(phrase => {
					const span = document.createElement('span');
					span.style.cssText = 'padding: 6px 12px; background: var(--card); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-size: 14px;';
					span.textContent = phrase;
					matchedResultsList.appendChild(span);
				});
			} else {
				matchedResults.style.display = 'none';
			}
			
			if (dictResult) {
				console.log('å­—å…¸æŸ¥è¯¢æˆåŠŸï¼Œæ‰¾åˆ°åŒ¹é…æ•°:', dictResult.length);
				console.log('dictResult:', dictResult);
				console.log('dictResult[0] ç±»å‹:', typeof dictResult[0]);
				console.log('dictResult[0] å€¼:', dictResult[0]);
			}
			
			let newInfos;
			// æ£€æŸ¥ dictResult æ˜¯å¦æ˜¯å¤šä¸ªå€™é€‰é¡¹ï¼ˆå­—ç¬¦ä¸²æ•°ç»„ï¼‰
			if (dictResult && Array.isArray(dictResult) && dictResult.length > 0 && typeof dictResult[0] === 'string') {
				// å­—å…¸æŸ¥è¯¢æˆåŠŸï¼Œè¿”å›å¤šä¸ªå€™é€‰é¡¹
				// dictResult æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ï¼Œæ¯ä¸ªå­—ç¬¦ä¸²æ˜¯ä¸€ä¸ªå€™é€‰è¯
				// ä¸ºæ¯ä¸ªå­—ç¬¦ä½ç½®ç”Ÿæˆå€™é€‰é¡¹åˆ—è¡¨
				const firstPhrase = Array.from(dictResult[0]); // ç¬¬ä¸€ä¸ªç»“æœä½œä¸ºé»˜è®¤ç»“æœ
				
				newInfos = tempInfosWithOverrides.map((info, idx) => {
					// ä¿ç•™é”å®šçŠ¶æ€
					if (oldInfos[idx] && oldInfos[idx].locked) {
						return { 
							...info, 
							generated: oldInfos[idx].generated || info.char, 
							candidates: [], // é”å®šçŠ¶æ€ä¸‹ä¸æ˜¾ç¤ºå€™é€‰é¡¹
							locked: true, 
							forcedTone: oldInfos[idx].forcedTone || null 
						};
					}
					
					// ä¸ºè¿™ä¸ªä½ç½®çš„æ‰€æœ‰å€™é€‰è¯æ”¶é›†ç¬¬ idx ä¸ªå­—ç¬¦
					const charCandidates = [];
					for (const phrase of dictResult) {
						const chars = Array.from(phrase);
						if (idx < chars.length) {
							const char = chars[idx];
							if (!charCandidates.includes(char)) {
								charCandidates.push(char);
							}
						}
					}
					
					console.log(`ä½ç½® ${idx}: candidates = ${JSON.stringify(charCandidates)}`);
					
					// ä½¿ç”¨ç¬¬ä¸€ä¸ªæŸ¥è¯¢ç»“æœçš„å¯¹åº”ä½ç½®çš„å­—ä½œä¸º generated
					const selectedChar = idx < firstPhrase.length ? firstPhrase[idx] : (charCandidates[0] || info.char);
					
					return { 
						...info, 
						generated: selectedChar, 
						candidates: charCandidates,
						locked: false, 
						forcedTone: oldInfos[idx] && oldInfos[idx].forcedTone !== undefined ? oldInfos[idx].forcedTone : null 
					};
				});
			} else {
				// å­—å…¸æŸ¥è¯¢å¤±è´¥,ä½¿ç”¨åŸé€»è¾‘
				newInfos = tempInfosWithOverrides.map((info, idx) => {
					if (info.fin === '-') {
						return { ...info, generated: info.char, locked: false, forcedTone: oldInfos[idx] && oldInfos[idx].forcedTone !== undefined ? oldInfos[idx].forcedTone : null };
					}
					// ä¿ç•™é”å®šçŠ¶æ€
					if (oldInfos[idx] && oldInfos[idx].locked) {
						return { 
							...info, 
							generated: oldInfos[idx].generated || info.char, 
							locked: true, 
							forcedTone: oldInfos[idx].forcedTone || null 
						};
					}
					const candidate = pickFromMap(info.fin, info.tone, looseness);
					return { 
						...info, 
						generated: candidate || info.char, 
						locked: false, 
						forcedTone: oldInfos[idx] && oldInfos[idx].forcedTone !== undefined ? oldInfos[idx].forcedTone : null 
					};
				});
			}
			
			currentInfos = newInfos;
			render(currentInfos, currentInfos.map((i) => i.generated).join(''));
		};

		const updateSingleChar = (index, newTone) => {
			const info = currentInfos[index];
			if (!info || !info.fin || info.fin === '-') return;
			
			const looseness = Number(document.getElementById('looseness').value);
			// allow explicit user tone change even if locked (user-initiated)
			info.forcedTone = newTone;
			info.tone = newTone !== null ? newTone : info.baseTone;
			const candidate = pickFromMap(info.fin, info.tone, looseness, newTone);
			info.generated = candidate || info.char;
			
			// Re-run process with updated tone
			process();
		};

		const render = (infos, text) => {
			const body = document.getElementById('detailBody');
			body.innerHTML = '';
			infos.forEach((i, index) => {
				const tr = document.createElement('tr');
				
				// ç¬¬ä¸€åˆ—ï¼šåŸå­—
				const td1 = document.createElement('td');
				td1.textContent = i.char;
				tr.appendChild(td1);
				
				// ç¬¬äºŒåˆ—ï¼šæ‹¼éŸ³
				const td2 = document.createElement('td');
				td2.textContent = i.raw || '-';
				tr.appendChild(td2);
				
				// ç¬¬ä¸‰åˆ—ï¼šå£°è°ƒ
				const td3 = document.createElement('td');
				td3.textContent = i.tone || '-';
				tr.appendChild(td3);
				
				// ç¬¬å››åˆ—ï¼šéŸµæ¯+å£°è°ƒæ§åˆ¶
				const td4 = document.createElement('td');
				const finSpan = document.createElement('span');
				finSpan.textContent = i.fin || '-';
				td4.appendChild(finSpan);
				
				if (i.tone !== '-') {
					const select = document.createElement('select');
					select.className = 'tone-select';
					select.dataset.index = index;
					select.style.cssText = 'padding: 4px; border-radius: 6px; border: 1px solid var(--border); background: var(--card); color: var(--text);';
					
					const opt0 = document.createElement('option');
					opt0.value = '';
					opt0.textContent = `åŸ (${i.tone})`;
					opt0.selected = i.forcedTone === null;
					select.appendChild(opt0);
					
					for (let tone = 1; tone <= 4; tone++) {
						const opt = document.createElement('option');
						opt.value = tone;
						opt.textContent = `${tone}å£°`;
						opt.selected = i.forcedTone == tone;
						select.appendChild(opt);
					}
					
					select.addEventListener('change', (e) => {
						const idx = Number(e.target.dataset.index);
						const val = e.target.value ? Number(e.target.value) : null;
						updateSingleChar(idx, val);
					});
					
					td4.appendChild(select);
				}
				tr.appendChild(td4);
				
				body.appendChild(tr);
			});
		};

		const loadOnlineDict = async () => {
			const btn = document.getElementById('loadDictBtn');
			const originalText = btn.textContent;
			btn.textContent = 'â³ åŠ è½½ä¸­...';
			btn.disabled = true;

			const dictSources = [
				{
					name: 'æœ¬åœ°ä¼˜åŒ–è¯åº“',
					url: './dict_optimized.json',
					processor: (data) => {
					const chars = new Set();
					// Support multiple formats
					if (Array.isArray(data)) {
						// Array of strings or objects
						data.forEach(item => {
							if (typeof item === 'string') {
								Array.from(item).forEach(ch => {
									if (/[\u4e00-\u9fa5]/.test(ch)) chars.add(ch);
								});
							} else if (item.word || item.char) {
								const word = item.word || item.char;
								Array.from(word).forEach(ch => {
									if (/[\u4e00-\u9fa5]/.test(ch)) chars.add(ch);
								});
							}
						});
					} else if (typeof data === 'object') {
						// Object with character arrays by rhyme
						Object.values(data).forEach(value => {
							if (Array.isArray(value)) {
								value.forEach(ch => {
									if (typeof ch === 'string' && /[\u4e00-\u9fa5]/.test(ch)) {
										chars.add(ch);
									}
								});
							}
						});
					}
					return Array.from(chars);å•Š
				}
				}
			];
		let loadedChars = null;
		let successSource = null;
		
		for (const source of dictSources) {
			try {
				btn.textContent = `â³ ${source.name}...`;
				
				const response = await fetch(source.url, { 
					method: 'GET',
					headers: { 'Accept': 'application/json' }
				});
				
				if (!response.ok) throw new Error('HTTP ' + response.status);
				
				const data = await response.json();
				const chars = source.processor(data);
				
				if (chars && chars.length > 0) {
					loadedChars = chars;
					successSource = source.name;
					break;
				}
			} catch (err) {
				console.warn(`${source.name} åŠ è½½å¤±è´¥:`, err);
				continue;
			}
		}

		if (!loadedChars || loadedChars.length === 0) {
			throw new Error('æ‰€æœ‰è¯åº“æºå‡åŠ è½½å¤±è´¥');
		}

		try {
			const chars = loadedChars;
			localStorage.setItem('ONLINE_DICT_CACHE', JSON.stringify(chars));
			localStorage.setItem('ONLINE_DICT_TIME', Date.now().toString());
			localStorage.setItem('ONLINE_DICT_SOURCE', successSource);
			
			// Refresh bank
			if (window.refreshRhymeBank) window.refreshRhymeBank();
			bankMap = registerBank();
			
			btn.textContent = `âœ“ å·²åŠ è½½ ${chars.length} å­—`;
			btn.style.background = 'rgba(34, 211, 238, 0.2)';
			
			// Update status display
			const dictStatus = document.getElementById('dictStatus');
			const dictStatusText = document.getElementById('dictStatusText');
			const date = new Date();
			dictStatus.style.display = 'block';
			dictStatusText.textContent = `ğŸ“– è¯åº“ï¼š${chars.length} ä¸ªæ±‰å­—ï¼ˆ${successSource}ï¼‰| ${date.toLocaleString('zh-CN')}`;
			
			setTimeout(() => {
				btn.innerHTML = `ğŸ“š å·²ç¼“å­˜ ${chars.length} å­—`;
				btn.disabled = false;
				btn.style.background = '';
			}, 2000);
			
		} catch (err) {
			console.error('è¯åº“ä¿å­˜å¤±è´¥:', err);
			btn.textContent = 'âœ— ä¿å­˜å¤±è´¥';
			btn.style.background = 'rgba(239, 68, 68, 0.2)';
			
			setTimeout(() => {
				btn.textContent = originalText;
				btn.disabled = false;
				btn.style.background = '';
			}, 2000);
		}
		};

		const init = () => {
			document.getElementById('go').addEventListener('click', process);
			document.getElementById('source').addEventListener('keydown', (e) => {
				if (e.ctrlKey && e.key === 'Enter') process();
			});

			const loosenInput = document.getElementById('looseness');
			const triggerRecalc = () => {
				if (document.getElementById('source').value.trim()) process();
			};
			loosenInput.addEventListener('input', triggerRecalc);
			loosenInput.addEventListener('change', triggerRecalc);

			const loadDictBtn = document.getElementById('loadDictBtn');
			loadDictBtn.addEventListener('click', loadOnlineDict);

			// Check if online dict is already loaded
			const updateDictStatus = () => {
				const cachedTime = localStorage.getItem('ONLINE_DICT_TIME');
				const dictStatus = document.getElementById('dictStatus');
				const dictStatusText = document.getElementById('dictStatusText');
				
				if (cachedTime) {
					const cached = localStorage.getItem('ONLINE_DICT_CACHE');
					if (cached) {
						try {
							const chars = JSON.parse(cached);
							const date = new Date(Number(cachedTime));
							const source = localStorage.getItem('ONLINE_DICT_SOURCE') || 'åœ¨çº¿è¯åº“';
							loadDictBtn.innerHTML = `ğŸ“š å·²ç¼“å­˜ ${chars.length} å­—`;
							loadDictBtn.title = 'ç‚¹å‡»é‡æ–°åŠ è½½è¯åº“';
							
							dictStatus.style.display = 'block';
							dictStatusText.textContent = `ğŸ“– è¯åº“ï¼š${chars.length} ä¸ªæ±‰å­—ï¼ˆ${source}ï¼‰| ${date.toLocaleString('zh-CN')}`;
						} catch (e) {}
					}
				}
			};
			
			updateDictStatus();

			loadScriptSeq([...cdnList], (err, url) => {
				if (err) {
					setOutputStatus('pinyin-pro æœªåŠ è½½ï¼Œå·²å°è¯•å¤‡ç”¨ CDNã€‚å¯æ‰‹åŠ¨ä¸‹è½½ pinyin-pro.js æ”¾åœ¨åŒç›®å½•ã€‚');
					return;
				}
				pinyinReady = true;
				bankMap = registerBank();
				setOutputStatus(`pinyin-pro å·²åŠ è½½ (${url})ï¼Œå¯ç‚¹å‡»ç”Ÿæˆã€‚`);
			});
			
			// åŠ è½½ä¼˜åŒ–å­—å…¸
			loadDict();
		};

		init();
	</script>
</body>
</html>
