<!DOCTYPE html>
<html lang="zh">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>ä¸­æ–‡æŠ¼éŸµç”Ÿæˆå™¨</title>
	<link rel="preconnect" href="https://unpkg.com" />
	<style>
		:root {
			--bg: #0f172a;
			--panel: #111827;
			--card: #0b1220;
			--text: #e2e8f0;
			--muted: #94a3b8;
			--accent: #7c3aed;
			--accent-2: #22d3ee;
			--border: #1f2937;
			--radius: 16px;
		}

		* {
			box-sizing: border-box;
		}

		body {
			margin: 0;
			min-height: 100vh;
			background: radial-gradient(circle at 20% 20%, rgba(124, 58, 237, 0.2), transparent 35%),
				radial-gradient(circle at 80% 10%, rgba(34, 211, 238, 0.2), transparent 30%),
				radial-gradient(circle at 50% 80%, rgba(56, 189, 248, 0.15), transparent 35%),
				var(--bg);
			color: var(--text);
			font-family: "DM Sans", "Segoe UI", system-ui, -apple-system, sans-serif;
			display: flex;
			align-items: center;
			justify-content: center;
			padding: 40px 16px 64px;
		}

		.shell {
			width: min(1000px, 100%);
			background: linear-gradient(145deg, rgba(255, 255, 255, 0.03), rgba(255, 255, 255, 0));
			border: 1px solid var(--border);
			border-radius: var(--radius);
			box-shadow: 0 30px 80px rgba(0, 0, 0, 0.35);
			overflow: hidden;
		}

		header {
			padding: 28px 32px 12px;
		}

		h1 {
			margin: 0;
			font-size: 28px;
			letter-spacing: 0.4px;
		}

		p.credit {
			margin: 6px 0 0;
			color: var(--muted);
			font-size: 12px;
			text-align: center;
		}

		p.subtitle {
			margin: 8px 0 0;
			color: var(--muted);
			font-size: 14px;
		}

		main {
			display: grid;
			grid-template-columns: 1.1fr 0.9fr;
			gap: 20px;
			padding: 0 32px 28px;
		}

		/* è®©ä¸‹é¢çš„ section ä¹Ÿä½¿ç”¨ç›¸åŒçš„å®½åº¦å¯¹é½ */
		.shell > section {
			margin: 0 32px 20px 32px;
		}

		.shell > .footer {
			margin: 0;
		}

		@media (max-width: 900px) {
			main {
				grid-template-columns: 1fr;
			}
		}

		@media (max-width: 600px) {
			body {
				padding: 20px 12px 40px;
			}
			header {
				padding: 20px 20px 8px;
			}
			h1 {
				font-size: 24px;
			}
			main {
				padding: 0 20px 20px;
			}
			.panel {
				padding: 16px;
			}
			.btn {
				padding: 10px 16px;
				font-size: 14px;
			}
			.btn.small {
				padding: 6px 10px;
				font-size: 12px;
			}
			textarea,
			input[type="text"] {
				padding: 12px;
				font-size: 15px; /* é˜²æ­¢iOSç¼©æ”¾ */
				min-height: 100px;
			}
			.controls {
				gap: 6px;
			}
			table {
				font-size: 12px;
			}
			th, td {
				padding: 6px;
			}
			.footer {
				padding: 8px 20px 16px;
				font-size: 11px;
			}
		}

		.panel {
			background: var(--panel);
			border: 1px solid var(--border);
			border-radius: calc(var(--radius) - 4px);
			padding: 20px;
			position: relative;
			overflow: hidden;
		}

		.panel::before {
			content: "";
			position: absolute;
			inset: 0;
			background: radial-gradient(circle at 30% 30%, rgba(124, 58, 237, 0.08), transparent 40%);
			pointer-events: none;
		}

		label {
			display: flex;
			align-items: center;
			justify-content: space-between;
			gap: 12px;
			font-weight: 600;
			margin-bottom: 10px;
		}

		textarea,
		input[type="text"] {
			width: 100%;
			background: var(--card);
			border: 1px solid var(--border);
			border-radius: 12px;
			padding: 14px;
			color: var(--text);
			font-size: 16px;
			transition: border 0.2s ease, box-shadow 0.2s ease;
			resize: vertical;
			min-height: 120px;
		}

		textarea:focus,
		input[type="text"]:focus {
			border-color: var(--accent);
			outline: none;
			box-shadow: 0 0 0 2px rgba(124, 58, 237, 0.25);
		}

		input[type="range"] {
			-webkit-appearance: none;
			appearance: none;
			width: 100%;
			height: 8px;
			background: rgba(255, 255, 255, 0.3);
			border: 1px solid var(--border);
			border-radius: 4px;
			cursor: pointer;
			outline: none;
		}

		input[type="range"]::-webkit-slider-thumb {
			-webkit-appearance: none;
			appearance: none;
			width: 20px;
			height: 20px;
			border-radius: 50%;
			background: linear-gradient(135deg, var(--accent), var(--accent-2));
			box-shadow: 0 2px 6px rgba(124, 58, 237, 0.3);
			cursor: pointer;
			transition: transform 0.2s ease;
			position: relative;
			z-index: 1;
		}

		input[type="range"]::-webkit-slider-thumb:hover {
			transform: scale(1.1);
		}

		input[type="range"]::-moz-range-thumb {
			width: 20px;
			height: 20px;
			border-radius: 50%;
			background: linear-gradient(135deg, var(--accent), var(--accent-2));
			box-shadow: 0 2px 6px rgba(124, 58, 237, 0.3);
			cursor: pointer;
			border: none;
			transition: transform 0.2s ease;
		}

		input[type="range"]::-moz-range-thumb:hover {
			transform: scale(1.1);
		}

		.controls {
			display: flex;
			flex-wrap: wrap;
			gap: 10px;
			margin-top: 12px;
			align-items: center;
		}

		.btn {
			background: linear-gradient(135deg, var(--accent), var(--accent-2));
			border: none;
			color: white;
			padding: 12px 18px;
			border-radius: 12px;
			font-weight: 700;
			cursor: pointer;
			/* ç§»é™¤ transform transitionï¼Œé¿å…ä¸ GSAP å†²çª */
			transition: box-shadow 0.3s ease, background 0.3s ease, border-color 0.3s ease;
			box-shadow: 0 10px 25px rgba(124, 58, 237, 0.25);
			position: relative;
			overflow: hidden;
		}

		/* ç§»é™¤ CSS hover transformï¼Œå®Œå…¨äº¤ç»™ GSAP */
		.btn:hover {
			box-shadow: 0 15px 30px rgba(124, 58, 237, 0.35);
		}

		/* å¸ƒå±€å¹³æ»‘è¿‡æ¸¡ */
		.shell, main, .panel, textarea, input[type="text"], .footer {
			transition: all 0.6s cubic-bezier(0.16, 1, 0.3, 1);
		}

		.btn.ghost {
			background: transparent;
			color: var(--text);
			border: 1px solid var(--border);
			box-shadow: none;
		}

		.btn.ghost:hover {
			border-color: var(--accent);
			box-shadow: 0 0 0 2px rgba(124, 58, 237, 0.2);
		}

		.btn.small {
			padding: 8px 12px;
			font-size: 14px;
			font-weight: 500;
		}

		.hint {
			color: var(--muted);
			font-size: 12px;
			margin-top: 6px;
		}

		.output {
			font-size: 22px;
			line-height: 1.6;
			min-height: 120px;
			word-break: break-all;
			margin-bottom: 10px;
		}

		.badge-row {
			display: flex;
			flex-wrap: wrap;
			gap: 8px;
			margin-top: 10px;
			font-size: 12px;
			color: var(--muted);
		}

		.badge {
			padding: 6px 10px;
			border-radius: 999px;
			background: rgba(124, 58, 237, 0.15);
			border: 1px solid rgba(124, 58, 237, 0.35);
			color: #d8b4fe;
			display: inline-flex;
			align-items: center;
			gap: 6px;
		}

		table {
			width: 100%;
			border-collapse: collapse;
			font-size: 13px;
		}

		th,
		td {
			border-bottom: 1px solid var(--border);
			padding: 8px;
			text-align: left;
			color: var(--muted);
		}

		th {
			color: var(--text);
			font-weight: 700;
		}

		.pill {
			display: inline-flex;
			align-items: center;
			gap: 4px;
			padding: 4px 10px;
			border-radius: 10px;
			background: rgba(34, 211, 238, 0.12);
			color: #a5f3fc;
			border: 1px solid rgba(34, 211, 238, 0.35);
			font-weight: 600;
			cursor: pointer;
			user-select: none;
			transition: all 0.2s ease;
		}

		.lock-btn {
			background: transparent;
			border: none;
			color: var(--text);
			padding: 0;
			border-radius: 0;
			cursor: pointer;
			font-size: 12px;
			line-height: 1;
		}

		.lock-btn.locked {
			background: transparent;
			border-color: transparent;
		}

		.pill:hover {
			background: rgba(34, 211, 238, 0.2);
			box-shadow: 0 0 10px rgba(34, 211, 238, 0.15);
		}

		.pill:active {
			transform: scale(0.95);
		}

		.small {
			font-size: 12px;
			color: var(--muted);
		}

		.footer {
			padding: 12px 32px 22px;
			color: var(--muted);
			font-size: 12px;
		}

		/* GSAP Background Blobs */
		.bg-blob {
			position: fixed;
			border-radius: 50%;
			filter: blur(80px);
			z-index: -1;
			opacity: 0.6;
			pointer-events: none;
		}
		.blob-1 { top: -10%; left: -10%; width: 50vw; height: 50vw; background: var(--accent); opacity: 0.15; }
		.blob-2 { bottom: -10%; right: -10%; width: 40vw; height: 40vw; background: var(--accent-2); opacity: 0.15; }
		.blob-3 { top: 40%; left: 40%; width: 30vw; height: 30vw; background: #3b82f6; opacity: 0.1; }
	</style>
</head>
<body>
	<div class="bg-blob blob-1"></div>
	<div class="bg-blob blob-2"></div>
	<div class="bg-blob blob-3"></div>

	<div class="shell">
		<header>
			<h1>è¿æŠ¼åŒè°ƒéŸµè„šç”Ÿæˆå™¨ v1.5.1 beta</h1>
			<p class="credit">Â©TRUEPEAK 2025 - DEVELOPED BY DANJUAN </p>
			<p class="subtitle">è¾“å…¥è¯è¯­ï¼Œè‡ªåŠ¨æå–æ‹¼éŸ³ã€å£°è°ƒä¸éŸµæ¯ï¼Œç”Ÿæˆæ¯ä¸ªå­—åŒå£°è°ƒåŒéŸµæ¯çš„æŠ¼éŸµå­—ä¸²ã€‚</p>
		</header>

		<main>
			<section class="panel">
				<div style="display: flex; align-items: center; justify-content: space-between; gap: 12px; font-weight: 600; margin-bottom: 10px;">
					<label for="source">è¯·è¾“å…¥è¦æŠ¼éŸµçš„è¯è¯­ï¼š</label>
					<a class="btn ghost small" href="custom.html">è‡ªå®šä¹‰è¯åº“</a>
				</div>
				<textarea id="source" placeholder="ç¤ºä¾‹ï¼šåºŸå£³"></textarea>

				<div class="controls" style="display: flex; flex-direction: column; gap: 1px; margin-top: 12px;">
					<div style="display: flex; gap: 10px; flex-wrap: wrap;">
						<button class="btn" id="go">ç”ŸæˆæŠ¼éŸµ</button>
						<button class="btn ghost small" id="loadDictBtn" title="ä»åœ¨çº¿è¯åº“åŠ è½½æ›´å¤šæ±‰å­—">ğŸ“š åŠ è½½è¯åº“</button>
					</div>
					<label class="small" for="looseness" style="margin-top: 10px;">éŸµè„šå®½æ¾åº¦ï¼ˆ0=ä¸¥æ ¼ï¼Œ1=æœ€æ¾ï¼‰</label>
					<input type="range" id="looseness" min="0" max="1" step="0.5" value="0.0" />
				</div>
				<div style="color:brown; font-size: small; font-weight: bold; text-align: center;" >*ä½¿ç”¨å‰è¯·å…ˆåŠ è½½è¯åº“*</div>
				<div class="hint">ä¸¥æ ¼ï¼šåŒéŸµåŒè°ƒ  | ä¸­ç­‰ï¼šéŸµæ¯æ”¾å®½ï¼ˆé¼»éŸ³ã€ç¿˜èˆŒï¼‰ | æœ€æ¾ï¼šéŸµæ¯è¿›ä¸€æ­¥æ”¾å®½ï¼Œå¿½ç•¥å£°è°ƒã€‚</div>
				<div class="hint">- ç”Ÿæˆç»“æœçš„è¯æ˜¯ä¹±ç çš„è¯ï¼Œè¯´æ˜æ²¡æœ‰ç»“æœï¼Œæ”¾å®½éŸµè„šå®½æ¾åº¦å³å¯</div>
				<div class="hint">- è¶Šå®½æ¾éœ€è¦æŸ¥è¯¢çš„æ—¶é—´è¶Šé•¿ï¼Œè¯·è€å¿ƒç­‰å¾…</div>
				
				
			</section>

			<section class="panel">
				<div style="font-weight: 600; margin-bottom: 14px;">ç”Ÿæˆç»“æœ</div>
				<div class="output" id="output"></div>
				<div class="badge-row" id="badges"></div>
			</section>

		</main>

		<section class="panel" style="margin: 0 32px 20px;">
			<label style="margin-bottom: 14px;">è§£æè¯¦æƒ…</label>
			<table>
				<thead>
					<tr>
						<th>åŸå­—</th>
						<th>æ‹¼éŸ³</th>
						<th>å£°è°ƒ</th>
						<th>éŸµæ¯</th>
					</tr>
				</thead>
				<tbody id="detailBody"></tbody>
			</table>
		</section>

		<section class="panel" style="margin: 0 32px 20px;">
			<div id="matchedResults" style="padding: 12px; background: rgba(34, 211, 238, 0.05); border: 1px solid var(--border); border-radius: 8px; display: none;">
				<div style="font-weight: 600; margin-bottom: 8px; color: var(--accent-2);">æ›´å¤šåŒ¹é…ç»“æœï¼š</div>
				<div id="matchedResultsList" style="display: flex; flex-wrap: wrap; gap: 8px;"></div>
			</div>
			<div id="dictStatus" style="margin-top: 12px; padding: 8px 12px; background: rgba(124, 58, 237, 0.08); border-radius: 8px; font-size: 12px; color: var(--muted); display: none;">
				<span id="dictStatusText"></span>
			</div>
		</section>

		<div class="footer">è¯åº“åŸºäºé›¾å‡‡æ‹¼éŸ³è¯åº“ä»¥åŠä¸­åæ–°åå­—å…¸æ•°æ®åº“ä»¥åŠæ¸…åå¤§å­¦å¼€æ”¾ä¸­æ–‡è¯åº“ï¼ŒæŸ¥è¯¢ç®—æ³•åŸºäº pinyin-pro è§£æã€‚ç‚¹å‡»"ğŸ“š åŠ è½½è¯åº“"å¯ä»åœ¨çº¿è¯å…¸è·å–7000+æ±‰å­—ï¼Œæ•°æ®ç¼“å­˜åœ¨æœ¬åœ°ï¼Œå¯ç¦»çº¿ä½¿ç”¨ã€‚</div>
	</div>

	<script src="./data.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js" onerror="console.warn('GSAP CDNåŠ è½½å¤±è´¥')"></script>
	<script>
		// GSAP Animations
		document.addEventListener("DOMContentLoaded", () => {
			// æ£€æŸ¥GSAPæ˜¯å¦åŠ è½½æˆåŠŸ
			if (typeof gsap === 'undefined') {
				console.warn('GSAPæœªåŠ è½½ï¼Œè·³è¿‡åŠ¨ç”»');
				return;
			}
			gsap.config({ nullTargetWarn: false });

			// 1. Background Blobs Floating
			gsap.to(".blob-1", {
				x: "20%", y: "20%", duration: 8, repeat: -1, yoyo: true, ease: "sine.inOut"
			});
			gsap.to(".blob-2", {
				x: "-20%", y: "-20%", duration: 10, repeat: -1, yoyo: true, ease: "sine.inOut", delay: 1
			});
			gsap.to(".blob-3", {
				x: "15%", y: "-15%", scale: 1.2, duration: 12, repeat: -1, yoyo: true, ease: "sine.inOut", delay: 2
			});

			// 2. Entry Animations
			const tl = gsap.timeline({ defaults: { ease: "power3.out" } });

			tl.from(".shell", {
				y: 30,
				opacity: 0,
				duration: 1,
				clearProps: "all"
			})
			.from("header h1", {
				y: 20,
				opacity: 0,
				duration: 0.4
			}, "-=0.8")
			.from("header .subtitle", {
				y: 10,
				opacity: 0,
				duration: 0.2
			}, "-=0.6")
			.from(".panel", {
				y: 30,
				opacity: 0,
				duration: 0.1,
				stagger: 0.15,
				clearProps: "all"
			}, "-=0.6")
			.from(".footer", {
				opacity: 0,
			duration: 1,
			clearProps: "all"
		}, "-=0.4");

		// 3. Interactive Elements
		const buttons = document.querySelectorAll(".btn");
		buttons.forEach(btn => {
			btn.addEventListener("mouseenter", () => {
				gsap.to(btn, { scale: 1.05, duration: 0.3, ease: "back.out(1.7)" });
			});
			btn.addEventListener("mouseleave", () => {
					gsap.to(btn, { scale: 0.92, duration: 0.1, ease: "power1.out" });
				});
				btn.addEventListener("mouseup", () => {
					gsap.to(btn, { scale: 1.05, duration: 0.4, ease: "elastic.out(1, 0.3)" });
				});
			});
            
            // Animate output when generated
            const goBtn = document.getElementById('go');
            goBtn.addEventListener('click', () => {
                 gsap.fromTo("#output", { opacity: 0.5, y: 5 }, { opacity: 1, y: 0, duration: 0.4, ease: "power2.out" });
                 gsap.fromTo("#badges", { opacity: 0, x: -10 }, { opacity: 1, x: 0, duration: 0.4, delay: 0.1, ease: "power2.out" });
                 // Table rows animation
                 setTimeout(() => {
                     gsap.from("#detailBody tr", {
                        opacity: 0,
                        x: -10,
                        stagger: 0.05,
                        duration: 0.4,
                        ease: "power2.out",
						clearProps: "all"
                     });
                 }, 50);
            });
		});
	</script>

	<script>
		const cdnList = [
			'https://unpkg.com/pinyin-pro@3.27.0/dist/index.js',
			'https://cdn.jsdelivr.net/npm/pinyin-pro@3.27.0/dist/index.js',
			// å¦‚æœéœ€è¦æœ¬åœ°å¤‡ç”¨ï¼Œå°† pinyin-pro.umd.js æ”¾åœ¨åŒç›®å½•å¹¶å–æ¶ˆä¸‹ä¸€è¡Œæ³¨é‡Š
			// './pinyin-pro.umd.js'
		];

		const loadScriptSeq = (list, cb) => {
			if (!list.length) return cb(new Error('å…¨éƒ¨ CDN åŠ è½½å¤±è´¥'));
			const [url, ...rest] = list;
			const s = document.createElement('script');
			s.src = url;
			s.onload = () => cb(null, url);
			s.onerror = () => {
				s.remove();
				loadScriptSeq(rest, cb);
			};
			document.head.appendChild(s);
		};

		const setOutputStatus = (msg) => {
			// Output element removed
		};
		const finals = [
			'iong', 'uang', 'iang', 'ueng', 'uan', 'ian', 'uen', 'iao', 'uai', 'ang', 'eng', 'ing', 'ong', 'ai', 'ei', 'ao', 'ou', 'an', 'en', 'in', 'un', 'vn', 'ia', 'ua', 'uo', 'ie', 'ue', 'ui', 'er', 'a', 'o', 'e', 'i', 'u', 'v'
		];

		let bankMap = new Map();
		let pinyinReady = false;
		let currentInfos = [];
		let currentDictResult = null; // å­˜å‚¨å­—å…¸æŸ¥è¯¢ç»“æœ
		let dict = null; // ä¼˜åŒ–å­—å…¸
		let locks = [];

		// åŠ è½½ä¼˜åŒ–å­—å…¸
		const loadDict = async () => {
			try {
				const resp = await fetch('dict_optimized.json');
				const text = await resp.text();
				dict = JSON.parse(text);
				console.log('å­—å…¸åŠ è½½æˆåŠŸ,å…±', Object.keys(dict).length, 'æ¡');
			} catch(e) {
				console.error('å­—å…¸åŠ è½½å¤±è´¥:', e);
			}
		};

		const normalize = (p) => p.replace(/\d/g, '').replace(/Ã¼/g, 'v').replace(/u:/g, 'v');

		// å°†é”®ç»Ÿä¸€è½¬æˆ v å½¢å¼ï¼Œå¹¶ç”Ÿæˆ v/u åŒç‰ˆæœ¬ï¼Œå…¼å®¹è¯å…¸ä¸­å¯èƒ½ç”¨ u è¡¨ç¤º Ã¼ çš„æƒ…å†µ
		const buildKeyVariants = (key) => {
			const base = String(key).replace(/Ã¼/g, 'v').replace(/u:/g, 'v');
			const variants = new Set([base, base.replace(/v/g, 'u')]);
			return Array.from(variants);
		};

		const extractTone = (p) => {
			const m = p.match(/(\d)/);
			return m ? Number(m[1]) : 0;
		};

		const detectFinal = (p) => {
			// æ ‡å‡†åŒ–ï¼šÃ¼ -> v
			let normalizedP = p.replace(/Ã¼/g, 'v').replace(/u:/g, 'v');
			
			// æå–å£°æ¯ï¼ˆæŒ‰é•¿åº¦æ’åºï¼Œç¡®ä¿ zh ä¼˜å…ˆäº zï¼‰
			const initials = ['zh', 'ch', 'sh', 'z', 'c', 's', 'b', 'p', 'm', 'f', 'd', 't', 'n', 'l', 'g', 'k', 'h', 'j', 'q', 'x', 'r', 'w', 'y'];
			let initial = '';
			for (const init of initials) {
				if (normalizedP.startsWith(init)) {
					initial = init;
					break;
				}
			}
			
			let rest = normalizedP.slice(initial.length);
			
			// ç‰¹æ®Šå¤„ç†ï¼šj/q/x/y åçš„ u å®é™…æ˜¯ Ã¼ (v)
			if (['j', 'q', 'x', 'y'].includes(initial) && rest.startsWith('u')) {
				rest = 'v' + rest.slice(1);
			}

			// --- æ–°å¢ï¼šiéŸµéš”ç¦»åè®® (Triple-I Isolation) ---
			if (rest === 'i') {
				if (['z', 'c', 's'].includes(initial)) {
					return { initial, final: 'i-flat' }; // å¹³èˆŒéŸ³
				} else if (['zh', 'ch', 'sh', 'r'].includes(initial)) {
					return { initial, final: 'i-retro' }; // ç¿˜èˆŒéŸ³
				}
				// å…¶ä»–å£°æ¯ï¼ˆb, p, m, d, t, n, l, j, q, x, yï¼‰ä¿æŒä¸º 'i'
			}
			// -------------------------------------------
			
			// å¦‚æœæ²¡æœ‰éŸµæ¯ï¼ˆæ¯”å¦‚ m, n, ng è‡ªæˆéŸ³èŠ‚ï¼‰ï¼Œè¿”å›åŸæ‹¼éŸ³ä½œä¸ºéŸµæ¯
			if (!rest) return { initial, final: normalizedP };
			
			return { initial, final: rest };
		};

		const toInfo = (char) => {
			const raw = window.pinyinPro.pinyin(char, {
				type: 'array',
				toneType: 'num',
				pattern: 'pinyin'
			})[0];

			if (!raw || /[a-z]/i.test(raw) === false) return null;

			const clean = normalize(raw);
			const tone = extractTone(raw);
			const parts = detectFinal(clean);
			return parts ? { char, raw, clean, tone, fin: parts.final, ini: parts.initial } : null;
		};

		const registerBank = () => {
			if (!window.pinyinPro || !window.pinyinPro.pinyin) return new Map();
			const source = typeof window.getRhymeBank === 'function' ? window.getRhymeBank() : window.RHYME_CHAR_BANK || [];
			const map = new Map();
			for (const item of source) {
				// å°†å¤šå­—è¯æ‹†æˆå•ä¸ªå­—ç¬¦
				const chars = Array.from(item);
				for (const ch of chars) {
					const info = toInfo(ch);
					if (!info) continue;
					const key = `${info.fin}-${info.tone}`;
					if (!map.has(key)) map.set(key, []);
					// é¿å…é‡å¤æ·»åŠ ç›¸åŒçš„å­—
					if (!map.get(key).includes(ch)) {
						map.get(key).push(ch);
					}
				}
			}
			return map;
		};

		const thirteenTracks = [
			{ name: 'å‘èŠ±è¾™', finals: ['a', 'ia', 'ua'] },
			{ name: 'æ¢­æ³¢è¾™', finals: ['o', 'e', 'uo'] },
			{ name: 'ä¹œæ–œè¾™', finals: ['ie', 'ue', 've'] },
			{ name: 'è¨€å‰è¾™', finals: ['an', 'ian', 'uan', 'van', 'Ã¼an'] },
			{ name: 'äººè¾°è¾™', finals: ['en', 'in', 'un', 'vn', 'Ã¼n'] },
			{ name: 'æ±Ÿé˜³è¾™', finals: ['ang', 'iang', 'uang'] },
			{ name: 'ä¸­ä¸œè¾™', finals: ['eng', 'ing', 'ong', 'iong'] },
			{ name: 'ä¸€ä¸ƒè¾™', finals: ['i', 'v', 'er', 'Ã¼', 'i-flat', 'i-retro'] },
			{ name: 'å§‘è‹è¾™', finals: ['u'] },
			{ name: 'æ€€æ¥è¾™', finals: ['ai', 'uai'] },
			{ name: 'ç°å †è¾™', finals: ['ei', 'ui', 'uei'] },
			{ name: 'é¥æ¡è¾™', finals: ['ao', 'iao'] },
			{ name: 'æ²¹æ±‚è¾™', finals: ['ou', 'iu', 'iou'] }
		];

		// æ¾ç´§åˆ†çº§ï¼š
		// 0ï¼ˆä¸¥æ ¼ï¼‰ï¼šåŒéŸµåŒè°ƒï¼ˆåŒºåˆ†å¹³ç¿˜èˆŒã€å‰åé¼»éŸ³ï¼‰
		// 1ï¼ˆä¸­ç­‰ï¼‰ï¼šåŒè°ƒï¼Œä½†éŸµæ¯æ”¾å®½ï¼ˆä¸åˆ†å¹³ç¿˜èˆŒï¼Œä¸åˆ†å‰åé¼»éŸ³ï¼‰
		// 2ï¼ˆæœ€æ¾ï¼‰ï¼šéŸµæ¯æ”¾å®½ï¼ˆåŒä¸Šï¼‰ï¼Œä¸”ä¸é™åˆ¶å£°è°ƒ
		const getLoosenessTier = (value) => {
			if (value >= 0.67) return 2;
			if (value >= 0.34) return 1;
			return 0;
		};

		// å…¼å®¹æ—§å­—å…¸é”®å€¼çš„æ‰©å±•æ˜ å°„
		const legacyKeyMap = {
			'i-flat': ['i'],
			'i-retro': ['i'],
			'i': [
				'i', 
				'z-retroflex', 'c-retroflex', 's-retroflex',
				'zh-retroflex-e', 'ch-retroflex-e', 'sh-retroflex-e', 'r-retroflex-e',
				'j-palatal', 'q-palatal', 'x-palatal'
			],
			'u': [
				'u',
				// æ—§ä»£ç æŠŠ zu, cu, su ä¹Ÿå½’ä¸º retroflexï¼Œæ‰€ä»¥ä¹Ÿè¦æŸ¥è¿™äº›
				'z-retroflex', 'c-retroflex', 's-retroflex',
				'zh-retroflex-e', 'ch-retroflex-e', 'sh-retroflex-e', 'r-retroflex-e'
			]
		};

		// ä»å­—å…¸æŸ¥è¯¢æ‹¼éŸ³ç»„åˆå¯¹åº”çš„è¯ç»„ï¼ˆæ–°ç®—æ³•ï¼‰
		// ä½¿ç”¨æœ€åä¸¤ä¸ªå­—çš„éŸµè„šä¸ºæŸ¥è¯¢æ¡ä»¶ï¼Œè¿”å›æ‰€æœ‰ç›¸å…³åŒ¹é…
		const queryDict = (infos, looseness) => {
			if (!infos || infos.length === 0) return null;
			
			// ä¿®æ”¹ï¼šä¸å†å¼ºåˆ¶åªå–æœ€åä¸¤ä¸ªå­—ï¼Œè€Œæ˜¯æ ¹æ®è¾“å…¥é•¿åº¦å†³å®š
			// ç”¨æˆ·è¦æ±‚ï¼šæŸ¥è¯¢æ¡ä»¶è·Ÿç”Ÿæˆç»“æœä¸€æ ·ï¼Œå­—æ•°ç”±ç”¨æˆ·è¾“å…¥å†³å®š
			let queryInfos = infos;
			
			// éªŒè¯éŸµè„šä¿¡æ¯çš„æœ‰æ•ˆæ€§
			const validInfos = queryInfos.filter(info => info.fin && info.fin !== '-');
			if (validInfos.length === 0) return null;
			
			const tier = getLoosenessTier(looseness);
			const allowToneRelax = tier >= 2;
			
			// ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„æŸ¥è¯¢é”®å˜ä½“
			const generateQueryKeys = (infos) => {
				const keys = [];
				const recurse = (index, current) => {
					if (index === infos.length) {
						keys.push(current.join('_'));
						return;
					}
					const info = infos[index];
					// Tier 2: æ‰€æœ‰å­—éƒ½å…è®¸å£°è°ƒæ”¾å®½ï¼ˆå› ä¸ºåªå¤„ç†æœ€åä¸¤ä¸ªå­—ï¼Œç»„åˆæ•°å¯æ§ï¼‰
					// Tier 0/1: å¿…é¡»ä¸¥æ ¼åŒ¹é…å£°è°ƒ
					const toneVariants = allowToneRelax ? [1,2,3,4] : [info.tone];
					
					// è·å–è¯¥éŸµæ¯çš„æ‰€æœ‰å˜ä½“
					const finVariants = buildFinalVariants(info.fin, tier);
					
					// æ‰©å±•ä¸ºæ—§å­—å…¸çš„é”®å€¼
					const expandedVariants = new Set();
					for (const v of finVariants) {
						expandedVariants.add(v);
						if (legacyKeyMap[v]) {
							legacyKeyMap[v].forEach(k => expandedVariants.add(k));
						}
					}

					for (const fin of expandedVariants) {
						for (const tone of toneVariants) {
							recurse(index + 1, [...current, `${fin}${tone}`]);
						}
					}
				};
				recurse(0, []);
				return keys;
			};
			
			const queryKeys = generateQueryKeys(validInfos);
			const queryVariantSet = new Set();
			queryKeys.forEach(k => {
				buildKeyVariants(k).forEach(v => queryVariantSet.add(v));
			});
			
			// åœ¨å­—å…¸ä¸­æœç´¢æ‰€æœ‰å¯èƒ½çš„åŒ¹é…
			const matchedByWordCount = {};
			const sourceLength = infos.length;
			
			// éå†ä¼˜åŒ–å­—å…¸å¯»æ‰¾åŒ¹é…
			if (dict) {
				for (const [dictKey, candidates] of Object.entries(dict)) {
					const dictVariants = buildKeyVariants(dictKey);
					const hasMatch = dictVariants.some(dk => {
						for (const qk of queryVariantSet) {
							if (dk === qk || dk.endsWith('_' + qk)) return true;
						}
						return false;
					});
					if (!hasMatch) continue;
					if (candidates && Array.isArray(candidates)) {
						for (const phrase of candidates) {
							const phraseLen = Array.from(phrase).length;
							// æŒ‰å­—æ•°åˆ†ç±»
							if (!matchedByWordCount[phraseLen]) {
								matchedByWordCount[phraseLen] = [];
							}
							if (!matchedByWordCount[phraseLen].includes(phrase)) {
								matchedByWordCount[phraseLen].push(phrase);
							}
						}
					}
				}
			}
			
			// ä¹Ÿä»è‡ªå®šä¹‰è¯åº“ä¸­æŸ¥è¯¢
			try {
				const customStr = localStorage.getItem('CUSTOM_RHYME_BANK');
				if (customStr) {
					const customBank = JSON.parse(customStr);
					if (Array.isArray(customBank)) {
						for (const phrase of customBank) {
							if (typeof phrase === 'string' && phrase.length > 0) {
								// æ£€æŸ¥è‡ªå®šä¹‰è¯æ˜¯å¦ä»¥æŸ¥è¯¢keyç»“å°¾
								const phraseInfos = Array.from(phrase).map(ch => toInfo(ch)).filter(Boolean);
								if (phraseInfos.length > 0) {
									const lastTwoPhrase = phraseInfos.length >= 2 ? phraseInfos.slice(-2) : phraseInfos;
													const phraseKeyParts = lastTwoPhrase.map(info => `${info.fin}${info.tone}`);
													const phraseKey = phraseKeyParts.join('_');
													const phraseVariants = buildKeyVariants(phraseKey);
													const hit = phraseVariants.some(v => queryVariantSet.has(v));
									
													if (hit) {
										const phraseLen = Array.from(phrase).length;
										if (!matchedByWordCount[phraseLen]) {
											matchedByWordCount[phraseLen] = [];
										}
										if (!matchedByWordCount[phraseLen].includes(phrase)) {
											matchedByWordCount[phraseLen].push(phrase);
										}
									}
								}
							}
						}
					}
				}
			} catch (e) {
				console.warn('è‡ªå®šä¹‰è¯åº“è¯»å–å¤±è´¥:', e);
			}
			
		// è¿”å›åˆ†ç±»ç»“æœ
		let sortedLengths = Object.keys(matchedByWordCount).map(Number).sort((a, b) => a - b);
		
		const sameLengthResults = [];
		const moreLengthResults = [];
		const lessLengthResults = [];
		
		// å…ˆæ·»åŠ ç›¸åŒå­—æ•°çš„åŒ¹é…
		const sameLengthCandidates = sortedLengths.filter(len => len === sourceLength);
		for (const len of sameLengthCandidates) {
			sameLengthResults.push(...matchedByWordCount[len]);
		}
		
		// æ”¶é›†å°‘ä¸€å­—çš„åŒ¹é…
		const targetLess = sourceLength - 1;
		if (targetLess >= 1 && matchedByWordCount[targetLess]) {
			lessLengthResults.push(...matchedByWordCount[targetLess]);
		}
		
		// å¦‚æœæ²¡æœ‰ç›¸åŒå­—æ•°çš„åŒ¹é…ï¼Œä¸”æºå­—æ•°å¤§äº2ï¼Œå°è¯•é™çº§æŸ¥è¯¢
		if (sameLengthResults.length === 0 && sourceLength > 2) {
			let currentLength = sourceLength - 1;
			while (currentLength >= 2 && sameLengthResults.length === 0) {
				// å–æœ«å°¾ currentLength ä¸ªå­—é‡æ–°æŸ¥è¯¢
				const shorterInfos = infos.slice(-currentLength);
				const shorterResult = queryDict(shorterInfos, looseness);
				
				if (shorterResult && shorterResult.sameLength && shorterResult.sameLength.length > 0) {
					sameLengthResults.push(...shorterResult.sameLength);
					console.log(`é™çº§æŸ¥è¯¢æˆåŠŸï¼šä» ${sourceLength} å­—é™åˆ° ${currentLength} å­—`);
					break;
				}
				
				currentLength--;
			}
		}
		
		// ç„¶åæ·»åŠ æ‰€æœ‰å­—æ•°æ›´å¤šçš„åŒ¹é…
		const moreLengthCandidates = sortedLengths.filter(len => len > sourceLength);
		for (const len of moreLengthCandidates) {
			moreLengthResults.push(...matchedByWordCount[len]);
		}
		
		return {
			sameLength: sameLengthResults.length > 0 ? sameLengthResults : null,
			lessLength: lessLengthResults.length > 0 ? lessLengthResults : null,
			moreLengths: moreLengthResults.length > 0 ? moreLengthResults : null
		};
	};

		const buildFinalVariants = (fin, tier) => {
			// Tier 0: ä¸¥æ ¼æ¨¡å¼ï¼Œå®Œå…¨åŒ¹é…
			if (tier === 0) return [fin];

			// Tier 1 & 2: å®½æ¾æ¨¡å¼ (åˆå¹¶å¹³ç¿˜èˆŒï¼Œåˆå¹¶å‰åé¼»éŸ³)
			
			// 1. å‰åé¼»éŸ³åˆå¹¶ï¼šè¨€å‰(an) + æ±Ÿé˜³(ang)
			const groupAnAng = ['an', 'ian', 'uan', 'van', 'Ã¼an', 'ang', 'iang', 'uang'];
			if (groupAnAng.includes(fin)) return groupAnAng;

			// 2. å‰åé¼»éŸ³åˆå¹¶ï¼šäººè¾°(en) + ä¸­ä¸œ(eng)
			const groupEnEng = ['en', 'in', 'un', 'vn', 'Ã¼n', 'eng', 'ing', 'ong', 'iong'];
			if (groupEnEng.includes(fin)) return groupEnEng;

			// 3. å…¶ä»–æƒ…å†µï¼ˆåŒ…æ‹¬ i-flat/i-retro å½’ä¸ºä¸€ä¸ƒè¾™ï¼‰ï¼Œä½¿ç”¨åä¸‰è¾™
			const track = thirteenTracks.find(t => t.finals.includes(fin));
			return track ? track.finals : [fin];
		};

		const normalizeSpecialFinal = (fin) => {
			// æ—§é€»è¾‘æ®‹ç•™ï¼Œç°åœ¨ç›´æ¥è¿”å› fin å³å¯
			return fin;
		};

		// æ£€æŸ¥å€™é€‰çŸ­è¯­æ˜¯å¦é€å­—åŒ¹é…æºè¯çš„éŸµè„šï¼ˆä¼˜å…ˆä¿è¯æ¯ä¸ªå­—çš„éŸµè„šä¸€è‡´ï¼‰
		const phraseFitsSource = (phrase, sourceInfos, looseness) => {
			const tier = getLoosenessTier(looseness);
			const allowToneRelax = tier >= 2; // Tier 2 å¿½ç•¥å£°è°ƒ
			const chars = Array.from(phrase);
			
			// ä¿®æ”¹ï¼šå§‹ç»ˆä»æœ«å°¾å¯¹é½è¿›è¡Œæ¯”è¾ƒ
			// æ— è®ºæ˜¯é•¿è¯è¿˜æ˜¯çŸ­è¯ï¼Œéƒ½æ¯”è¾ƒæœ«å°¾å¯¹åº”çš„å­—
			const len = Math.min(chars.length, sourceInfos.length);
			const srcOffset = sourceInfos.length - len;
			const phraseOffset = chars.length - len;

			// å®šä¹‰ç‰¹æ®Šå£°æ¯é›†åˆï¼ˆå¹³ç¿˜èˆŒï¼‰
			const specialInitials = ['zh', 'ch', 'sh', 'r', 'z', 'c', 's'];

			for (let i = 0; i < len; i++) {
				const src = sourceInfos[srcOffset + i];
				const ch = chars[phraseOffset + i];
				const pInfo = ch ? toInfo(ch) : null;
				if (!src || !pInfo || !src.fin || src.fin === '-') return false;
				
				// æ£€æŸ¥éŸµæ¯å…¼å®¹æ€§
				let rhymeOk = false;
				if (tier === 0) {
					// ä¸¥æ ¼ï¼šå¿…é¡»å®Œå…¨ç›¸åŒ
					rhymeOk = (src.fin === pInfo.fin);
				} else {
					// å®½æ¾ï¼šæ£€æŸ¥æ˜¯å¦åœ¨åŒä¸€ä¸ªå˜ä½“ç»„ä¸­
					const variants = buildFinalVariants(src.fin, tier);
					rhymeOk = variants.includes(pInfo.fin);
				}
				
				if (!rhymeOk) return false;
				
				// æ£€æŸ¥å£°è°ƒ
				// Tier 0 & 1: å£°è°ƒå¿…é¡»ç›¸åŒ
				// Tier 2: å£°è°ƒå¯ä¸åŒ
				const toneOk = allowToneRelax || (src.tone === pInfo.tone);
				if (!toneOk) return false;

				// --- æ–°å¢ï¼šå£°æ¯ç±»å‹è¿‡æ»¤ ---
				// è§„åˆ™ï¼šå¦‚æœæºå­—å£°æ¯ä¸æ˜¯å¹³ç¿˜èˆŒéŸ³ï¼Œåˆ™åŒ¹é…å­—å£°æ¯ä¹Ÿä¸èƒ½æ˜¯å¹³ç¿˜èˆŒéŸ³ã€‚
				// é¿å…â€œè‡ªå¾‹(l)â€åŒ¹é…åˆ°â€œä¸–ä¸–(sh)â€è¿™ç§å¬æ„Ÿå·®å¼‚å·¨å¤§çš„æƒ…å†µã€‚
				const srcIsSpecial = specialInitials.includes(src.ini);
				const matchIsSpecial = specialInitials.includes(pInfo.ini);
				
				if (!srcIsSpecial && matchIsSpecial) {
					return false;
				}
				// -------------------------
			}
			return true;
		};

		const pickFromMap = (fin, originalTone, looseness, forceTone = null) => {
			const tier = getLoosenessTier(looseness);
			
			// å¯¹äºç‰¹æ®Šæ ‡è®°çš„éŸµæ¯ï¼Œä¸è¿›è¡Œæ‰©å±•
			let finalsToTry;
			if (fin.includes('-')) {
				finalsToTry = [fin];
			} else {
				finalsToTry = buildFinalVariants(fin, tier);
			}

			let targetTones = [];
			if (forceTone !== null) {
				targetTones = [Number(forceTone)];
			} else {
				// Tier 2: æ‰€æœ‰å£°è°ƒ
				// Tier 0/1: ä¸¥æ ¼å£°è°ƒ
				if (tier >= 2) {
					targetTones = [1, 2, 3, 4];
				} else {
					targetTones = [originalTone];
				}
			}

			const candidates = [];
			for (const f of finalsToTry) {
				for (const t of targetTones) {
					candidates.push(...(bankMap.get(`${f}-${t}`) || []));
				}
			}

			// å¦‚æœæœ€æ¾æ¡£ä¸”æ²¡æœ‰ç»“æœï¼Œæ‰å°è¯•å¿½ç•¥å£°è°ƒ
			if (candidates.length === 0 && tier >= 2 && !forceTone) {
				// å·²ç»åœ¨ä¸Šé¢å¤„ç†äº†æ‰€æœ‰å£°è°ƒï¼Œè¿™é‡Œä¸éœ€è¦é¢å¤–é€»è¾‘ï¼Œé™¤é bankMap ç¼ºå¤±
			}

			if (candidates.length === 0) return null;
			return candidates[Math.floor(Math.random() * candidates.length)];
		};

		const process = () => {
			const src = document.getElementById('source').value.trim();
			const looseness = Number(document.getElementById('looseness').value);
			if (!pinyinReady || !window.pinyinPro || !window.pinyinPro.pinyin) {
				render([], 'pinyin-pro æœªåŠ è½½ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–ç¨åé‡è¯•', null, '');
				return;
			}
			if (bankMap.size === 0) bankMap = registerBank();
			if (!src) {
				render([], 'ç­‰å¾…è¾“å…¥...', null, '');
				return;
			}

			// Build new infos but preserve locked/forced settings from previous run
			const oldInfos = Array.isArray(currentInfos) ? currentInfos.slice() : [];
			
			// å…ˆæå–æ‰€æœ‰å­—ç¬¦çš„æ‹¼éŸ³ä¿¡æ¯ï¼Œè®°å½•åŸºå‡†å£°è°ƒ
			const tempInfos = Array.from(src).map((ch) => {
				const info = toInfo(ch);
				if (!info) return { char: ch, raw: '-', tone: '-', baseTone: '-', fin: '-', forcedTone: null };
				return { ...info, baseTone: info.tone, forcedTone: null };
			});

			// åº”ç”¨ç”¨æˆ·åœ¨è§£æè¡¨ä¸­é€‰æ‹©çš„å¼ºåˆ¶å£°è°ƒ
			const tempInfosWithOverrides = tempInfos.map((info, idx) => {
				const old = oldInfos[idx];
				const forcedTone = old && old.forcedTone !== null ? old.forcedTone : null;
				const tone = forcedTone !== null ? forcedTone : info.baseTone;
				return { ...info, tone, forcedTone };
			});
			
			// å°è¯•ä»å­—å…¸æŸ¥è¯¢æ•´å¥
			const dictResult = queryDict(tempInfosWithOverrides, looseness);
			currentDictResult = dictResult; // ä¿å­˜åˆ°å…¨å±€å˜é‡ä¾›renderä½¿ç”¨
			
			// è·å–ç”¨æˆ·è¾“å…¥çš„åŸè¯ï¼ˆç”¨äºæ’é™¤ï¼‰
			const userInput = tempInfosWithOverrides.map(info => info.char).join('');
			
			// æ˜¾ç¤ºåŒ¹é…ç»“æœï¼ˆå­—æ•°æ›´å¤šçš„ï¼‰
			const matchedResults = document.getElementById('matchedResults');
			const matchedResultsList = document.getElementById('matchedResultsList');
			
			// é¦–å…ˆæ¸…ç©ºåˆ—è¡¨
			matchedResultsList.innerHTML = '';
			
			// ä¼˜å…ˆå±•ç¤ºâ€œå°‘ä¸€å­—â€çš„åŒ¹é…ï¼Œå…¶æ¬¡å†å±•ç¤ºæ›´å¤šå­—æ•°çš„åŒ¹é…
			const seen = new Set();
			const appendPhrase = (phrase) => {
				if (seen.has(phrase)) return;
				// æ’é™¤ä¸ç”¨æˆ·è¾“å…¥ç›¸åŒçš„è¯
				if (phrase === userInput) return;
				// æ’é™¤åŒ…å«ç”¨æˆ·è¾“å…¥è¯çš„è¯
				if (phrase.includes(userInput)) return;
				seen.add(phrase);
				const span = document.createElement('span');
				span.style.cssText = 'padding: 6px 12px; background: var(--card); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-size: 14px;';
				span.textContent = phrase;
				matchedResultsList.appendChild(span);
			};

			if (dictResult) {
				// å°‘ä¸€å­—åŒ¹é…
				if (dictResult.lessLength && dictResult.lessLength.length > 0) {
					const filteredLess = dictResult.lessLength.filter(phrase => phraseFitsSource(phrase, tempInfosWithOverrides, looseness));
					const displayLess = filteredLess.length > 0 ? filteredLess : dictResult.lessLength;
					displayLess.forEach(appendPhrase);
				}

				// æ›´å¤šå­—åŒ¹é…
				if (dictResult.moreLengths && dictResult.moreLengths.length > 0) {
					const filteredMore = dictResult.moreLengths.filter(phrase => phraseFitsSource(phrase, tempInfosWithOverrides, looseness));
					const displayMore = filteredMore.length > 0 ? filteredMore : dictResult.moreLengths;
					displayMore.forEach(appendPhrase);
				}
			}
			
			// å§‹ç»ˆæ˜¾ç¤ºå®¹å™¨
			matchedResults.style.display = 'block';
			
			if (dictResult) {
				console.log('å­—å…¸æŸ¥è¯¢æˆåŠŸ');
				console.log('ç›¸åŒå­—æ•°ç»“æœ:', dictResult.sameLength);
				console.log('æ›´é•¿å­—æ•°ç»“æœ:', dictResult.moreLengths);
			}
			
			let newInfos;
			// æ£€æŸ¥ dictResult æ˜¯å¦æ˜¯å¤šä¸ªå€™é€‰é¡¹ï¼ˆå­—ç¬¦ä¸²æ•°ç»„ï¼‰
			if (dictResult && dictResult.sameLength && Array.isArray(dictResult.sameLength) && dictResult.sameLength.length > 0) {
				// ä¼˜å…ˆé€å­—éŸµè„šåŒ¹é…ï¼ˆæ‰€æœ‰å­—éƒ½è¦æ»¡è¶³æºè¯çš„éŸµæ¯/å£°è°ƒè§„åˆ™ï¼‰ï¼›è‹¥æ— ï¼Œå†é€€å›â€œæœ«ä¸¤å­—â€åŒ¹é…ç»“æœ
				const tier = getLoosenessTier(looseness);
				const allowToneRelax = tier >= 2;
				const strongMatches = dictResult.sameLength.filter((phrase) => 
					// æ’é™¤ä¸ç”¨æˆ·è¾“å…¥ç›¸åŒçš„è¯å’ŒåŒ…å«ç”¨æˆ·è¾“å…¥çš„è¯
					phrase !== userInput && !phrase.includes(userInput) && phraseFitsSource(phrase, tempInfosWithOverrides, looseness)
				);
				const ranked = strongMatches.length > 0 ? strongMatches : [];
				
				if (ranked.length === 0) {
					// å­—å…¸æŸ¥è¯¢æ²¡æœ‰é€šè¿‡è¿‡æ»¤çš„ç»“æœï¼Œé€€å›åˆ°é€å­—é€‰æ‹©çš„æ¨¡å¼
					newInfos = tempInfosWithOverrides.map((info, idx) => {
						if (info.fin === '-') {
							return { ...info, generated: info.char, locked: false, forcedTone: oldInfos[idx] && oldInfos[idx].forcedTone !== undefined ? oldInfos[idx].forcedTone : null };
						}
						// ä¿ç•™é”å®šçŠ¶æ€
						if (oldInfos[idx] && oldInfos[idx].locked) {
							return { 
								...info, 
								generated: oldInfos[idx].generated || info.char, 
								locked: true, 
								forcedTone: oldInfos[idx].forcedTone || null 
							};
						}
						const candidate = pickFromMap(info.fin, info.tone, looseness);
						return { 
							...info, 
							generated: candidate || info.char, 
							locked: false, 
							forcedTone: oldInfos[idx] && oldInfos[idx].forcedTone !== undefined ? oldInfos[idx].forcedTone : null 
						};
					});
				} else {
					const firstPhrase = Array.from(ranked[0]); // ç¬¬ä¸€æ¡ä½œä¸ºé»˜è®¤ç”Ÿæˆ
					
					newInfos = tempInfosWithOverrides.map((info, idx) => {
						// ä¿ç•™é”å®šçŠ¶æ€
						if (oldInfos[idx] && oldInfos[idx].locked) {
							return { 
								...info, 
								generated: oldInfos[idx].generated || info.char, 
								candidates: [], // é”å®šçŠ¶æ€ä¸‹ä¸æ˜¾ç¤ºå€™é€‰é¡¹
								locked: true, 
								forcedTone: oldInfos[idx].forcedTone || null 
							};
						}
						
						// ä¸ºè¿™ä¸ªä½ç½®çš„æ‰€æœ‰å€™é€‰è¯æ”¶é›†ç¬¬ idx ä¸ªå­—ç¬¦
						const charCandidates = [];
						for (const phrase of ranked) {
							const chars = Array.from(phrase);
							if (idx < chars.length) {
								const char = chars[idx];
								if (!charCandidates.includes(char)) {
									charCandidates.push(char);
								}
							}
						}
						
					// æ’é™¤ä¼šä½¿ç»“æœä¸ç”¨æˆ·è¾“å…¥ç›¸åŒçš„å­—ç¬¦
					const filteredCandidates = charCandidates.filter(char => {
						// æ„å»ºå‡è®¾é€‰æ‹©è¯¥å­—ç¬¦åçš„å®Œæ•´è¯ï¼ˆä½¿ç”¨firstPhraseä½œä¸ºåŸºå‡†ï¼‰
						const testPhrase = firstPhrase.map((c, i) => 
							i === idx ? char : c
						).join('');
						return testPhrase !== userInput;
					});
					
					console.log(`ä½ç½® ${idx}: candidates = ${JSON.stringify(filteredCandidates)}`);
					
					// ä½¿ç”¨æ’åç¬¬ä¸€çš„çŸ­è¯­å¯¹åº”ä½ç½®çš„å­—ä½œä¸º generatedï¼Œä½†è¦é¿å…ç”Ÿæˆç”¨æˆ·è¾“å…¥
					let selectedChar = firstPhrase[idx];
					// å¦‚æœ firstPhrase ä¼šå¯¼è‡´ä¸ç”¨æˆ·è¾“å…¥ç›¸åŒï¼Œä½¿ç”¨è¿‡æ»¤åçš„å€™é€‰
					const wouldMatchInput = firstPhrase.join('') === userInput;
					if (wouldMatchInput && filteredCandidates.length > 0) {
						selectedChar = filteredCandidates[0];
					} else if (wouldMatchInput && charCandidates.length > 0) {
						// å¦‚æœè¿‡æ»¤åæ²¡æœ‰å€™é€‰ï¼Œå°è¯•ä»åŸå§‹å€™é€‰ä¸­æ‰¾ä¸€ä¸ªä¸åŒçš„
						const differentChar = charCandidates.find(c => c !== info.char);
						selectedChar = differentChar || charCandidates[0];
					}
					
					return { 
						...info, 
						generated: selectedChar, 
						candidates: filteredCandidates.length > 0 ? filteredCandidates : charCandidates,
						locked: false, 
						forcedTone: oldInfos[idx] && oldInfos[idx].forcedTone !== undefined ? oldInfos[idx].forcedTone : null 
					};
				});
			}
		} else {
			// å­—å…¸æŸ¥è¯¢å¤±è´¥,ä½¿ç”¨åŸé€»è¾‘
			newInfos = tempInfosWithOverrides.map((info, idx) => {
				if (info.fin === '-') {
					return { ...info, generated: info.char, locked: false, forcedTone: oldInfos[idx] && oldInfos[idx].forcedTone !== undefined ? oldInfos[idx].forcedTone : null };
				}
				// ä¿ç•™é”å®šçŠ¶æ€
				if (oldInfos[idx] && oldInfos[idx].locked) {
					return { 
						...info, 
						generated: oldInfos[idx].generated || info.char, 
						locked: true, 
						forcedTone: oldInfos[idx].forcedTone || null 
					};
				}
				const candidate = pickFromMap(info.fin, info.tone, looseness);
				return { 
					...info, 
					generated: candidate || info.char, 
					locked: false, 
					forcedTone: oldInfos[idx] && oldInfos[idx].forcedTone !== undefined ? oldInfos[idx].forcedTone : null 
				};
			});
		}
		
		currentInfos = newInfos;
		render(currentInfos, currentInfos.map((i) => i.generated).join(''), currentDictResult, userInput);
	};

	const render = (infos, text, dictResult, userInput) => {
			// æ›´æ–°å³ä¾§ç”Ÿæˆç»“æœé¢æ¿
			const output = document.getElementById('output');
			const badges = document.getElementById('badges');
			
			if (output) {
				// æ˜¾ç¤ºç›¸åŒå­—æ•°çš„æ‰€æœ‰åŒ¹é…ç»“æœï¼ˆæ¥è‡ªdictResultï¼‰
				const results = [];
				
				// å…ˆæ˜¾ç¤ºå½“å‰ç”Ÿæˆç»“æœï¼ˆæ’é™¤ä¸ç”¨æˆ·è¾“å…¥ç›¸åŒçš„è¯ï¼‰
				if (text && text !== userInput) {
					results.push(text);
				}
				
				// ç„¶åæ·»åŠ å­—å…¸ä¸­çš„ç›¸åŒå­—æ•°ç»“æœï¼ˆå¿…é¡»é€šè¿‡phraseFitsSourceè¿‡æ»¤ï¼‰
				if (dictResult && dictResult.sameLength && Array.isArray(dictResult.sameLength)) {
					const looseness = Number(document.getElementById('looseness').value);
					for (const phrase of dictResult.sameLength) {
						// æ’é™¤ç”¨æˆ·è¾“å…¥å’Œå·²ç»åœ¨ç»“æœä¸­çš„è¯
						if (phrase !== text && phrase !== userInput && !results.includes(phrase)) {
							// ä¸¥æ ¼æ£€æŸ¥è¯¥è¯æ˜¯å¦çœŸæ­£ç¬¦åˆæºè¯çš„éŸµè„šè¦æ±‚
							if (phraseFitsSource(phrase, infos, looseness)) {
								results.push(phrase);
							}
						}
					}
				}
				
				// ç”¨åˆ¶è¡¨ç¬¦åˆ†éš”æ˜¾ç¤ºæ‰€æœ‰ç»“æœåœ¨åŒä¸€è¡Œ
				const resultText = results.join('\t');
				output.style.whiteSpace = 'pre-wrap';
				output.style.wordBreak = 'keep-all';
				output.style.overflowWrap = 'normal';
				output.textContent = resultText || '-';
				output.style.fontFamily = 'var(--font-family, "DM Sans", "Segoe UI", system-ui, -apple-system, sans-serif)';
				output.style.fontSize = '18px';
				output.style.fontWeight = '500';
				output.style.lineHeight = '1.8';
				output.style.letterSpacing = '0.5px';
			}
			
			if (badges) {
				badges.innerHTML = '';
				if (text) {
					const badge = document.createElement('div');
					badge.className = 'badge';
					badge.innerHTML = `âœ¨ ${text.length} å­—`;
					badges.appendChild(badge);
				}
			}
			
			// æ›´æ–°ä¸‹æ–¹è¯¦æƒ…è¡¨æ ¼
			const body = document.getElementById('detailBody');
			body.innerHTML = '';
			infos.forEach((i, index) => {
				const tr = document.createElement('tr');
				
				// ç¬¬ä¸€åˆ—ï¼šåŸå­—
				const td1 = document.createElement('td');
				td1.textContent = i.char;
				tr.appendChild(td1);
				
				// ç¬¬äºŒåˆ—ï¼šæ‹¼éŸ³
				const td2 = document.createElement('td');
				td2.textContent = i.raw || '-';
				tr.appendChild(td2);
				
				// ç¬¬ä¸‰åˆ—ï¼šå£°è°ƒ
				const td3 = document.createElement('td');
				td3.textContent = i.tone || '-';
				tr.appendChild(td3);
				
				// ç¬¬å››åˆ—ï¼šéŸµæ¯+å£°è°ƒæ§åˆ¶
				const td4 = document.createElement('td');
				const finSpan = document.createElement('span');
				finSpan.textContent = i.fin || '-';
				td4.appendChild(finSpan);
				
				if (i.tone !== '-') {
					const select = document.createElement('select');
					select.className = 'tone-select';
					select.dataset.index = index;
					select.style.cssText = 'padding: 4px; border-radius: 6px; border: 1px solid var(--border); background: var(--card); color: var(--text);';
					
					const opt0 = document.createElement('option');
					opt0.value = '';
					opt0.textContent = `åŸ (${i.tone})`;
					opt0.selected = i.forcedTone === null;
					select.appendChild(opt0);
					
					for (let tone = 1; tone <= 4; tone++) {
						const opt = document.createElement('option');
						opt.value = tone;
						opt.textContent = `${tone}å£°`;
						opt.selected = i.forcedTone == tone;
						select.appendChild(opt);
					}
					
					select.addEventListener('change', (e) => {
						const idx = Number(e.target.dataset.index);
						const val = e.target.value ? Number(e.target.value) : null;
						updateSingleChar(idx, val);
					});
					
					td4.appendChild(select);
				}
				tr.appendChild(td4);
				
				body.appendChild(tr);
			});
		};

		const loadOnlineDict = async () => {
			const btn = document.getElementById('loadDictBtn');
			const originalText = btn.textContent;
			btn.textContent = 'â³ åŠ è½½ä¸­...';
			btn.disabled = true;

			// Check if Web Worker is supported
			if (typeof Worker === 'undefined') {
				// Fallback to synchronous loading if Worker not supported
				console.warn('Web Worker not supported, using fallback method');
				await loadOnlineDictFallback();
				return;
			}

			try {
				// Create progress display element if not exists
				let progressBar = document.getElementById('dictProgressBar');
				if (!progressBar) {
					progressBar = document.createElement('div');
					progressBar.id = 'dictProgressBar';
					progressBar.style.cssText = `
						position: fixed;
						top: 0;
						left: 0;
						right: 0;
						height: 3px;
						background: linear-gradient(90deg, #7c3aed, #22d3ee);
						z-index: 9999;
						display: none;
						width: 0%;
						transition: width 0.3s ease;
					`;
					document.body.insertBefore(progressBar, document.body.firstChild);
				}
				progressBar.style.display = 'block';

				// Use Web Worker for background processing
				const worker = new Worker('./dict-worker.js');

				const dictSources = [
					{
						name: 'æœ¬åœ°ä¼˜åŒ–è¯åº“',
						url: './dict_optimized.json'
					}
				];

				return new Promise((resolve, reject) => {
					const timeout = setTimeout(() => {
						worker.terminate();
						reject(new Error('è¯åº“åŠ è½½è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥'));
					}, 120000); // 2 minutes timeout

					worker.onmessage = (event) => {
						const { type, message, data, progress, percent } = event.data;

						if (type === 'progress' || type === 'parsing') {
							btn.textContent = message || `åŠ è½½ä¸­... ${percent || progress}%`;
							if (percent) {
								progressBar.style.width = percent + '%';
							}
						}

						if (type === 'success') {
							clearTimeout(timeout);
							worker.terminate();

							const { chars, sourceName, stats } = data;
							try {
								localStorage.setItem('ONLINE_DICT_CACHE', JSON.stringify(chars));
								localStorage.setItem('ONLINE_DICT_TIME', Date.now().toString());
								localStorage.setItem('ONLINE_DICT_SOURCE', sourceName);
								// Store detailed stats for reference
								if (stats) {
									localStorage.setItem('ONLINE_DICT_STATS', JSON.stringify(stats));
								}

								// Refresh bank
								if (window.refreshRhymeBank) window.refreshRhymeBank();
								bankMap = registerBank();

								btn.textContent = `âœ“ å·²åŠ è½½ ${chars.length} å­—`;
								btn.style.background = 'rgba(34, 211, 238, 0.2)';
								progressBar.style.width = '100%';

								const dictStatus = document.getElementById('dictStatus');
								const dictStatusText = document.getElementById('dictStatusText');
								const date = new Date();
								dictStatus.style.display = 'block';
								
								// Build detailed status text with stats
								let statusText = `ğŸ“– è¯åº“ï¼š${chars.length} ä¸ªå”¯ä¸€æ±‰å­—ï¼ˆ${sourceName}ï¼‰`;
								if (stats && stats.totalChars) {
									statusText += ` | æ•°æ®ç»Ÿè®¡ï¼š${stats.categories.toLocaleString()} åˆ†ç±»ï¼Œ${stats.totalStrings.toLocaleString()} æ¡ç›®ï¼Œ${stats.totalChars.toLocaleString()} å­—ç¬¦ï¼ˆå»é‡å‰ï¼‰`;
								}
								statusText += ` | ${date.toLocaleString('zh-CN')}`;
								dictStatusText.textContent = statusText;

								setTimeout(() => {
									btn.innerHTML = `ğŸ“š å·²ç¼“å­˜ ${chars.length} å­—`;
									btn.disabled = false;
									btn.style.background = '';
									progressBar.style.display = 'none';
								}, 1500);

								resolve();
							} catch (err) {
								reject(err);
							}
						}

						if (type === 'error') {
							clearTimeout(timeout);
							worker.terminate();
							reject(new Error(message));
						}
					};

					worker.onerror = (err) => {
						clearTimeout(timeout);
						worker.terminate();
						reject(err);
					};

					// Send message to worker
					worker.postMessage({
						action: 'loadAndProcess',
						payload: { dictSources }
					});
				});
			} catch (err) {
				console.error('è¯åº“åŠ è½½å¤±è´¥:', err);
				btn.textContent = `âœ— ${err.message || 'åŠ è½½å¤±è´¥'}`;
				btn.style.background = 'rgba(239, 68, 68, 0.2)';
				progressBar?.style.display && (progressBar.style.display = 'none');

				setTimeout(() => {
					btn.textContent = originalText;
					btn.disabled = false;
					btn.style.background = '';
				}, 3000);
			}
		};

		const loadOnlineDictFallback = async () => {
			// Synchronous fallback for browsers without Web Worker support
			const btn = document.getElementById('loadDictBtn');
			const originalText = btn.textContent;

			try {
				const response = await fetch('./dict_optimized.json', {
					method: 'GET',
					headers: { 'Accept': 'application/json' }
				});

				if (!response.ok) throw new Error('HTTP ' + response.status);

				btn.textContent = 'â³ è§£æä¸­...';
				const data = await response.json();
				const chars = new Set();
				let stats = {
					totalStrings: 0,
					totalChars: 0,
					uniqueChars: 0,
					categories: 0
				};

				if (Array.isArray(data)) {
					stats.categories = 1;
					data.forEach((item, idx) => {
						if (idx % 5000 === 0) {
							btn.textContent = `â³ è§£æä¸­... ${Math.round((idx / data.length) * 100)}%`;
						}
						if (typeof item === 'string') {
							stats.totalStrings++;
							Array.from(item).forEach(ch => {
								if (/[\u4e00-\u9fa5]/.test(ch)) {
									stats.totalChars++;
									chars.add(ch);
								}
							});
						}
					});
				} else if (data && typeof data === 'object') {
					const entries = Object.entries(data);
					stats.categories = entries.length;
					entries.forEach(([, value], idx) => {
						if (idx % 500 === 0) {
							btn.textContent = `â³ è§£æä¸­... ${Math.round((idx / entries.length) * 100)}%`;
						}
						if (Array.isArray(value)) {
							stats.totalStrings += value.length;
							value.forEach(item => {
								if (typeof item === 'string') {
									Array.from(item).forEach(ch => {
										if (/[\u4e00-\u9fa5]/.test(ch)) {
											stats.totalChars++;
											chars.add(ch);
										}
									});
								}
							});
						}
					});
				}

				const charArray = Array.from(chars);
				stats.uniqueChars = charArray.length;
				
				localStorage.setItem('ONLINE_DICT_CACHE', JSON.stringify(charArray));
				localStorage.setItem('ONLINE_DICT_TIME', Date.now().toString());
				localStorage.setItem('ONLINE_DICT_SOURCE', 'æœ¬åœ°ä¼˜åŒ–è¯åº“');
				localStorage.setItem('ONLINE_DICT_STATS', JSON.stringify(stats));

				if (window.refreshRhymeBank) window.refreshRhymeBank();
				bankMap = registerBank();

				btn.textContent = `âœ“ å·²åŠ è½½ ${charArray.length} å­—`;
				btn.style.background = 'rgba(34, 211, 238, 0.2)';

				const dictStatus = document.getElementById('dictStatus');
				const dictStatusText = document.getElementById('dictStatusText');
				dictStatus.style.display = 'block';
				
				let statusText = `ğŸ“– è¯åº“ï¼š${charArray.length} ä¸ªå”¯ä¸€æ±‰å­—ï¼ˆæœ¬åœ°ä¼˜åŒ–è¯åº“ï¼‰`;
				if (stats.totalChars > 0) {
					statusText += ` | æ•°æ®ç»Ÿè®¡ï¼š${stats.categories.toLocaleString()} åˆ†ç±»ï¼Œ${stats.totalStrings.toLocaleString()} æ¡ç›®ï¼Œ${stats.totalChars.toLocaleString()} å­—ç¬¦ï¼ˆå»é‡å‰ï¼‰`;
				}
				statusText += ` | ${new Date().toLocaleString('zh-CN')}`;
				dictStatusText.textContent = statusText;

				setTimeout(() => {
					btn.innerHTML = `ğŸ“š å·²ç¼“å­˜ ${charArray.length} å­—`;
					btn.disabled = false;
					btn.style.background = '';
				}, 1500);
			} catch (err) {
				console.error('è¯åº“åŠ è½½å¤±è´¥:', err);
				btn.textContent = 'âœ— åŠ è½½å¤±è´¥';
				btn.style.background = 'rgba(239, 68, 68, 0.2)';

				setTimeout(() => {
					btn.textContent = originalText;
					btn.disabled = false;
					btn.style.background = '';
				}, 3000);
			}
		};

		// Debounce å‡½æ•°
		const debounce = (func, delay) => {
			let timeoutId;
			return (...args) => {
				clearTimeout(timeoutId);
				timeoutId = setTimeout(() => func(...args), delay);
			};
		};

		const init = () => {
			document.getElementById('go').addEventListener('click', process);
			document.getElementById('source').addEventListener('keydown', (e) => {
				if (e.ctrlKey && e.key === 'Enter') process();
			});

			const loosenInput = document.getElementById('looseness');
			const triggerRecalc = () => {
				if (document.getElementById('source').value.trim()) process();
			};
			// ä½¿ç”¨ debounceï¼Œå»¶è¿Ÿ 300ms åå†æ‰§è¡ŒæŸ¥è¯¢
			const debouncedRecalc = debounce(triggerRecalc, 100);
			loosenInput.addEventListener('input', debouncedRecalc);
			loosenInput.addEventListener('change', triggerRecalc);

			const loadDictBtn = document.getElementById('loadDictBtn');
			loadDictBtn.addEventListener('click', loadOnlineDict);

			// Check if online dict is already loaded
			const updateDictStatus = () => {
				const cachedTime = localStorage.getItem('ONLINE_DICT_TIME');
				const dictStatus = document.getElementById('dictStatus');
				const dictStatusText = document.getElementById('dictStatusText');
				
				if (cachedTime) {
					const cached = localStorage.getItem('ONLINE_DICT_CACHE');
					if (cached) {
						try {
							const chars = JSON.parse(cached);
							const date = new Date(Number(cachedTime));
							const source = localStorage.getItem('ONLINE_DICT_SOURCE') || 'åœ¨çº¿è¯åº“';
							loadDictBtn.innerHTML = `ğŸ“š å·²ç¼“å­˜ ${chars.length} å­—`;
							loadDictBtn.title = 'ç‚¹å‡»é‡æ–°åŠ è½½è¯åº“';
							
							dictStatus.style.display = 'block';
							
							// Try to load and display stats if available
							let statusText = `ğŸ“– è¯åº“ï¼š${chars.length} ä¸ªå”¯ä¸€æ±‰å­—ï¼ˆ${source}ï¼‰`;
							try {
								const statsStr = localStorage.getItem('ONLINE_DICT_STATS');
								if (statsStr) {
									const stats = JSON.parse(statsStr);
									if (stats.totalChars > 0) {
										statusText += ` | æ•°æ®ç»Ÿè®¡ï¼š${stats.categories.toLocaleString()} åˆ†ç±»ï¼Œ${stats.totalStrings.toLocaleString()} æ¡ç›®ï¼Œ${stats.totalChars.toLocaleString()} å­—ç¬¦ï¼ˆå»é‡å‰ï¼‰`;
									}
								}
							} catch (e) {}
							
							statusText += ` | ${date.toLocaleString('zh-CN')}`;
							dictStatusText.textContent = statusText;
						} catch (e) {}
					}
				}
			};
			
			updateDictStatus();

			// Expose debug utilities to window for console access
			window.dictDebug = {
				showStats: function() {
					const stats = localStorage.getItem('ONLINE_DICT_STATS');
					const cache = localStorage.getItem('ONLINE_DICT_CACHE');
					const source = localStorage.getItem('ONLINE_DICT_SOURCE');
					const time = localStorage.getItem('ONLINE_DICT_TIME');
					
					console.clear();
					console.log('%cè¯åº“ç»Ÿè®¡ä¿¡æ¯', 'font-size:16px; font-weight:bold; color:#7c3aed');
					console.log('æ¥æº:', source || 'æœªåŠ è½½');
					console.log('åŠ è½½æ—¶é—´:', time ? new Date(parseInt(time)).toLocaleString('zh-CN') : 'æœªåŠ è½½');
					
					if (cache) {
						const chars = JSON.parse(cache);
						console.log('å”¯ä¸€æ±‰å­—æ•°:', chars.length);
					}
					
					if (stats) {
						const s = JSON.parse(stats);
						console.table({
							'åˆ†ç±»æ•°': s.categories.toLocaleString(),
							'æ¡ç›®æ•°ï¼ˆå­—ç¬¦ä¸²ï¼‰': s.totalStrings.toLocaleString(),
							'å­—ç¬¦æ€»æ•°ï¼ˆå»é‡å‰ï¼‰': s.totalChars.toLocaleString(),
							'å”¯ä¸€æ±‰å­—æ•°': s.uniqueChars.toLocaleString(),
							'é‡å¤åº¦': ((1 - s.uniqueChars / s.totalChars) * 100).toFixed(2) + '%'
						});
					} else {
						console.log('ï¼ˆæ— è¯¦ç»†ç»Ÿè®¡ï¼Œå¯é‡æ–°åŠ è½½è¯åº“è·å–ï¼‰');
					}
				},
				
				cacheSize: function() {
					let total = 0;
					for (let key in localStorage) {
						if (key.startsWith('ONLINE_DICT_')) {
							const size = localStorage[key].length;
							console.log(`${key}: ${(size / 1024).toFixed(2)} KB`);
							total += size;
						}
					}
					console.log(`æ€»è®¡: ${(total / 1024 / 1024).toFixed(2)} MB`);
				}
			};
			
			console.log('%cğŸ’¡ æç¤º', 'color:#22d3ee; font-weight:bold');
			console.log('åœ¨æ§åˆ¶å°æ‰§è¡Œä»¥ä¸‹å‘½ä»¤æŸ¥çœ‹è¯åº“ä¿¡æ¯ï¼š');
			console.log('  â€¢ window.dictDebug.showStats()  - æ˜¾ç¤ºè¯¦ç»†ç»Ÿè®¡');
			console.log('  â€¢ window.dictDebug.cacheSize()  - æ˜¾ç¤ºç¼“å­˜å¤§å°');

			loadScriptSeq([...cdnList], (err, url) => {
				if (err) {
					setOutputStatus('pinyin-pro æœªåŠ è½½ï¼Œå·²å°è¯•å¤‡ç”¨ CDNã€‚å¯æ‰‹åŠ¨ä¸‹è½½ pinyin-pro.js æ”¾åœ¨åŒç›®å½•ã€‚');
					return;
				}
				pinyinReady = true;
				bankMap = registerBank();
				setOutputStatus(`pinyin-pro å·²åŠ è½½ (${url})ï¼Œå¯ç‚¹å‡»ç”Ÿæˆã€‚`);
			});
			
			// åŠ è½½ä¼˜åŒ–å­—å…¸
			loadDict();
		};

		init();
	</script>
</body>
</html>
